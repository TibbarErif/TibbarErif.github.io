<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="《名为怪物的游戏》框架开发篇（场景系统）"><meta name="keywords" content="开发技术,unity"><meta name="author" content="火烧兔子"><meta name="copyright" content="火烧兔子"><title>《名为怪物的游戏》框架开发篇（场景系统） | 火兔游戏工作室</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-6777753891073316',
  enable_page_level_ads: 'true'
});
</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">2.</span> <span class="toc-text">参考资料</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6"><span class="toc-number">3.</span> <span class="toc-text">游戏框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.</span> <span class="toc-text">模块设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%84%E8%8C%83%E5%BC%80%E5%8F%91%E5%88%86%E6%94%AF"><span class="toc-number">5.</span> <span class="toc-text">规范开发分支</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">6.</span> <span class="toc-text">场景系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%9C%BA%E6%99%AF"><span class="toc-number">6.1.</span> <span class="toc-text">主场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9B%BE%E7%9A%84%E5%88%87%E6%8D%A2%E5%8E%9F%E7%90%86"><span class="toc-number">6.2.</span> <span class="toc-text">地图的切换原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%9C%BA%E6%99%AF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.3.</span> <span class="toc-text">主场景的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%B0%E5%9B%BE%E7%B3%BB%E7%BB%9F"><span class="toc-number">7.</span> <span class="toc-text">地图系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BE%8E%E6%9C%AF%E8%B5%84%E6%BA%90"><span class="toc-number">7.1.</span> <span class="toc-text">美术资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E8%A7%92%E8%89%B2"><span class="toc-number">7.2.</span> <span class="toc-text">地图中的角色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9B%BE%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">7.3.</span> <span class="toc-text">地图控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9B%BE%E8%8A%82%E7%82%B9"><span class="toc-number">7.3.1.</span> <span class="toc-text">地图节点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#NPC-%E8%8A%82%E7%82%B9"><span class="toc-number">7.3.1.1.</span> <span class="toc-text">NPC 节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%92%E8%89%B2%E8%8A%82%E7%82%B9"><span class="toc-number">7.3.1.2.</span> <span class="toc-text">角色节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E6%B8%B8%E6%88%8F%E4%B8%AD%E8%B0%83%E7%94%A8"><span class="toc-number">7.3.1.3.</span> <span class="toc-text">在游戏中调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E5%BB%BA%E9%80%A0%E5%99%A8"><span class="toc-number">7.3.1.4.</span> <span class="toc-text">游戏对象建造器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%92%E8%89%B2%E8%8A%82%E7%82%B9%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">7.3.1.5.</span> <span class="toc-text">角色节点生成器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E8%8A%82%E7%82%B9"><span class="toc-number">7.3.1.6.</span> <span class="toc-text">查询节点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E4%BA%8B%E4%BB%B6"><span class="toc-number">7.3.2.</span> <span class="toc-text">自动加载事件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">7.3.2.1.</span> <span class="toc-text">事件触发器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%AE%B9%E5%99%A8"><span class="toc-number">7.3.2.2.</span> <span class="toc-text">事件容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-number">7.3.2.3.</span> <span class="toc-text">事件触发条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E4%BA%8B%E4%BB%B6%E7%B1%BB"><span class="toc-number">7.3.2.4.</span> <span class="toc-text">抽象事件类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NPC-%E4%BA%8B%E4%BB%B6"><span class="toc-number">7.3.3.</span> <span class="toc-text">NPC 事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%A7%E6%83%85%E6%BC%94%E5%87%BA%E7%B3%BB%E7%BB%9F"><span class="toc-number">7.3.4.</span> <span class="toc-text">剧情演出系统</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">7.3.4.1.</span> <span class="toc-text">管理器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%AE%B9%E5%99%A8-1"><span class="toc-number">7.3.4.2.</span> <span class="toc-text">事件容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E4%BA%8B%E4%BB%B6%E5%8A%A8%E4%BD%9C"><span class="toc-number">7.3.4.3.</span> <span class="toc-text">抽象事件动作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%A7%84%E8%8C%83"><span class="toc-number">7.3.4.4.</span> <span class="toc-text">文件规范</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">8.</span> <span class="toc-text">场景系统结构图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E5%B0%BE"><span class="toc-number">9.</span> <span class="toc-text">结尾</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://i.loli.net/2021/05/02/JjR7MmfePax3oc2.jpg"></div><div class="author-info__name text-center">火烧兔子</div><div class="author-info__description text-center">我的世界，在你手中。</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">157</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">44</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">30</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2021/05/02/61DLs9VHetxbq2n.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">火兔游戏工作室</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/archives">归档</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">《名为怪物的游戏》框架开发篇（场景系统）</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-10</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%96%B0%E6%B8%B8%E5%BC%80%E5%8F%91/">新游开发</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%96%B0%E6%B8%B8%E5%BC%80%E5%8F%91/%E5%90%8D%E4%B8%BA%E6%80%AA%E7%89%A9%E7%9A%84%E6%B8%B8%E6%88%8F/">名为怪物的游戏</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>游戏框架可以理解为一个具有自动处理功能并且有着丰富可调用方法的类库。</p>
<p>提前写好各种通用方法，存入“框架”的方法库，然后开发就可以直接调用。<br>其实就是利用了“复用性”原则，把一些可以反复使用的方法抽取出来，作为全局调用类。</p>
<blockquote>
<p>面向“复用”编程</p>
</blockquote>
<p>方法库只是框架的基本功能，最主要的还是框架对于逻辑的自动处理。<br>比如切换场景时的淡入淡出效果，传送到某个地图，自动判断是否要触发剧情事件等等。</p>
<p>开发者只要写好触发条件，框架就能自动处理一些繁琐的过程。</p>
<p>因为游戏的定制性很强，所以网上没有什么好的框架，但是有许多插件包可以使用。<br>如果是别人开源好用的插件包，也可以直接引入框架中使用，减少自己的开发时间。</p>
<blockquote>
<p>例如加密系统，需要对存档进行加密防止被本地修改，就要用到第三方的加密插件，当然也可以自己来写加密方法，但是自己写的无法跟专业人士相比，已经有十分成熟的开源插件，就没必要自己重复造轮子。原创系统也不会因为使用了别人的插件包就不叫做“原创”了，现代主流的框架基本都是依赖第三方包，如 PHP 的 composer，JavaScript 的 npm 等等，正是因为站在巨人的肩膀上，我们才能往更高的地方前进。</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>游戏设计模式：<a target="_blank" rel="noopener" href="https://gpp.tkchu.me/introduction.html">https://gpp.tkchu.me/introduction.html</a></p>
<h2 id="游戏框架"><a href="#游戏框架" class="headerlink" title="游戏框架"></a>游戏框架</h2><p>游戏框架相当于工厂的流水线，只要设计好流水线，工厂的生产效率就能大幅提升。<br>框架的作用就是帮助开发者减少重复开发的时间，提高类的复用性。</p>
<p>框架的代码不应该与游戏本身的逻辑存在耦合。<br>耦合即有关联的意思，也就是说，框架应该是可以独立出来用在任何一个新游戏上面的。<br>而不是说只为了这个游戏开发框架。</p>
<p>除此之外，框架还将复杂的操作封装起来，只暴露出一个简单易调用的方法。<br>因此使用框架的时候，只需要关注开发游戏本身，而不需要关注内部是如何实现的。</p>
<p>那么接下来就一边学习一边尝试开发出一套属于自己的游戏框架。</p>
<h2 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h2><p>一套 RPG 游戏的框架包括：</p>
<ul>
<li>场景系统</li>
<li>角色系统</li>
<li>装备系统</li>
<li>战斗系统</li>
<li>敌人系统</li>
<li>事件系统</li>
<li>任务系统</li>
<li>……</li>
</ul>
<p>诸如此类，以模块进行区分，逐一实现各个功能。</p>
<h2 id="规范开发分支"><a href="#规范开发分支" class="headerlink" title="规范开发分支"></a>规范开发分支</h2><p>代码管理工具用的是 Git，因为是开发新的系统框架，所以单独切换出一条分支进行开发。</p>
<p><img src="https://pic.imgdb.cn/item/610f534f5132923bf8d36cfb.jpg" alt="分支切换"></p>
<p>新版本取名为 <code>v1.1.0</code>，中版本号更新一位。<br>等系统更新完成再合并到 <code>master</code> 主分支。</p>
<p>然后推送到仓库服务器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin v1.1.0</span><br></pre></td></tr></table></figure>

<p>这样就单独创建了一条新的分支，框架的开发在这条分支上进行。<br>代码仓库使用的是：<a target="_blank" rel="noopener" href="http://coding.net/">http://coding.net</a><br>也可以使用 Github，不过不稳定，国内有时候要翻墙才能访问。</p>
<p>除此之外，国产的还有：<a target="_blank" rel="noopener" href="https://gitee.com/">https://gitee.com/</a><br>其他的我就没使用过了，国产的也不是很稳定，偶尔也会出现推送不上去或拉不下来的情况，但是访问速度比国外的快得多。</p>
<p><img src="https://pic.imgdb.cn/item/610f54435132923bf8d4a4f6.jpg" alt="代码仓库"></p>
<p>为了提高效率，编写了一个 <code>shell</code> 脚本用来自动提交代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;shell_$1&quot;</span><br><span class="line">git push</span><br><span class="line">echo &quot;shell 快捷提交___$1 上传完成...\n&quot;</span><br></pre></td></tr></table></figure>

<p>这样每次提交代码只需要：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;autoloadSave.sh 测试</span><br></pre></td></tr></table></figure>

<p>直接省略了输入 git 命令，懒人必备！</p>
<h2 id="场景系统概述"><a href="#场景系统概述" class="headerlink" title="场景系统概述"></a>场景系统概述</h2><p>游戏中分为主场景（负责全局的逻辑处理）以及地图。</p>
<p><img src="https://pic.imgdb.cn/item/610f40de5132923bf8bb687a.jpg" alt="场景系统"></p>
<h3 id="主场景"><a href="#主场景" class="headerlink" title="主场景"></a>主场景</h3><p>主场景就是 Unity 的 Scene（场景）。<br>游戏中只有一个主场景，其他的地图全部使用 Prefab（预制体）来实现。<br>这其实就是框架中常说的“单一入口”。</p>
<p>Unity 中的 Scene：</p>
<p><img src="https://pic.imgdb.cn/item/610f43a35132923bf8bf3213.jpg" alt="Scene"></p>
<p>Unity 中的 Prefab：</p>
<p><img src="https://pic.imgdb.cn/item/610f43c15132923bf8bf583e.jpg" alt="Prefab"></p>
<h3 id="地图的切换原理"><a href="#地图的切换原理" class="headerlink" title="地图的切换原理"></a>地图的切换原理</h3><p>Prefab 放在 Resources 文件夹进行动态加载，主场景就是玩家当前所在的场景。<br>玩家切换地图时，并不是场景的切换，而是销毁当前地图的节点，然后通过预制体创建新地图的节点。</p>
<p>通常的游戏开发是一个地图就创建一个 Scene。<br>然后调用切换场景的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SceneManager.LoadScene(&quot;MiniGame&quot;);</span><br></pre></td></tr></table></figure>

<p>这样是真正的场景切换。<br>如果是体量比较小的游戏，没有几个场景就可以这么做。<br>但是我们的新游戏是长篇的 RPG，粗略的估计地图也有好几百个。</p>
<p>创建一个新的场景，就需要重新配置 Canvas（摄像机）和场景控制器节点。<br>这么做非常麻烦，因此把地图作为 Prefab（预制体）动态加载的方法就可以复用主场景中的 Canvas 和控制器节点。</p>
<blockquote>
<p>单一场景有一个缺点就是很容易出现内存泄露的情况，所谓内存泄露就是没用的变量或者资源没有及时销毁从而白白占用系统内存空间。如果是 Unity 自带的 SceneManager 来切换场景，变量及资源会在切换场景时自动回收，但是单一场景，所有的内存回收都要自己操作，如果不小心忘记了，就会造成内存泄露，结果就是游戏玩得越久，越变越卡。</p>
</blockquote>
<h3 id="主场景的实现"><a href="#主场景的实现" class="headerlink" title="主场景的实现"></a>主场景的实现</h3><p>主场景主要负责场景相关逻辑的处理。<br>玩家开始游戏后，只会载入一次主场景，然后由主场景判断当前需要加载的地图。</p>
<p>比如玩家打开游戏，载入主场景，此时显示的是标题界面。<br>如果玩家选择开始新游戏，就会载入游戏的初始地图；<br>如果玩家选择的是读取存档，就会加载存档数据的地图。</p>
<p>除了控制地图的加载，初始资源的加载也是在主场景进行的。<br>例如：本地化的语言文本，游戏的常驻资源等等。</p>
<p>编写 <code>FR_MainScene</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace FR_Scene</span><br><span class="line">&#123;</span><br><span class="line">    public abstract class FR_MainScene : MonoBehaviour</span><br><span class="line">    &#123;</span><br><span class="line">        protected void Awake()</span><br><span class="line">        &#123;</span><br><span class="line">            InitMainSceneAction();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected void Start()</span><br><span class="line">        &#123;</span><br><span class="line">            OnLoadAction();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected abstract void InitMainSceneAction();</span><br><span class="line">        protected abstract void OnLoadAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>InitMainSceneAction</code> 方法是场景的初始化方法，用于加载配置文件以及其他资源。<br><code>OnLoadAction</code> 方法在载入主场景时的处理方法，例如打开游戏时载入标题画面。</p>
<p>这两个方法需要在子类进行实现。</p>
<blockquote>
<p>由于是编写游戏框架，所有框架类都需要加上命名空间，这样做的好处是以后可以单独抽取出来，下次如果还要开发新游戏就可以直接把这套框架导入到新游戏的工程中。框架与当前游戏的逻辑进行解耦，只抽取出公共的方法，具体的实现通过继承接口或者抽象类的方式来完成。</p>
</blockquote>
<p>这里使用了 <code>abstract</code> 来声明方法应当在子类进行实现。实际上在子类直接调用 <code>Start</code> 和 <code>Awake</code> 也没什么差别，抽象方法的作用是“约束”，也就是要子类强制按照规定好的标准写代码，下文也会遵循这样的设计。</p>
<blockquote>
<p>框架的作用就是制定一些列的标准，使开发者能够按照统一的要求进行开发。</p>
</blockquote>
<p>主场景的代码现在这样就够了，接下来编写地图系统。</p>
<h2 id="地图系统"><a href="#地图系统" class="headerlink" title="地图系统"></a>地图系统</h2><p>地图系统就比较复杂了。</p>
<p>一个游戏地图包括：地图中的美术资源、角色、NPC、可调查事件。<br>逻辑的处理又包括：查找地图中的节点，自动触发事件的处理。<br>还有操作方面的处理：监听玩家按键（如打开菜单、控制玩家移动）。</p>
<h3 id="美术资源"><a href="#美术资源" class="headerlink" title="美术资源"></a>美术资源</h3><p>地图的美术资源需要分层，比如桌子是在地板的上面。<br>地图的分层可以理解为 Photoshop 的图层。</p>
<p><img src="https://pic.imgdb.cn/item/610f4ea75132923bf8cd67ed.jpg" alt="图层"></p>
<p>例如，玩家走到桌子前面会被遮挡。</p>
<p><img src="https://pic.imgdb.cn/item/610f4f005132923bf8cddadb.jpg" alt="遮挡效果"></p>
<p>这其实就是桌子的图层比玩家所在的图层高，所以桌子显示在上层，玩家显示在下层，所以被遮挡了。<br>Unity 提供了 Sort 字段来控制图层的层级关系：</p>
<p><img src="https://pic.imgdb.cn/item/610f4f6c5132923bf8ce6a2c.jpg" alt="sort"></p>
<p>该值越高，图层就显示在上方。<br>利用该值来控制地图的层级关系。</p>
<blockquote>
<p>这里将使用 100 为单位，比如底层是 0，第一层就是 100，第二层是 200，这样做的好处是可以设置 101、102 这样的值来进行更加细致的分层。</p>
</blockquote>
<p>为了方便直观的看出图层，每一个地图都有几个空的根节点 <code>Div_1</code>、<code>Div_2</code> 以此类推。</p>
<p><img src="https://pic.imgdb.cn/item/610f501e5132923bf8cf4a39.jpg" alt="空的根节点"></p>
<p><code>sort</code> 值为<code>100~199</code> 的就放在 <code>Div_1</code>，值为 <code>200~299</code> 的就放在 <code>Div_2</code>，玩家控制的角色放在第三层就可以了，值为 399（其他的 NPC 节点也在第三层，主角是最高的 399，这样就可以显示在 NPC 的上方）。</p>
<h3 id="地图中的角色"><a href="#地图中的角色" class="headerlink" title="地图中的角色"></a>地图中的角色</h3><p>先创建一个角色节点，给角色加上刚体，然后用物理学的方式来控制玩家移动，再加上 Unity 的动画系统，就实现了角色行走+移动动画。但这些并不是框架类要实现的，因为这已经是与游戏本身相关的逻辑了。</p>
<blockquote>
<p>通常的 RPG 游戏有四方向行走，但是我们的新作只能左右移动，这不是“通用”的，所以不能在框架里写角色的移动逻辑。</p>
</blockquote>
<p>框架中的角色类只要最基本的方法，操作控制需要抽取出来，让子类自行实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace FR_Scene</span><br><span class="line">&#123;</span><br><span class="line">    public abstract class FR_Character : MonoBehaviour</span><br><span class="line">    &#123;</span><br><span class="line">        private void Awake()</span><br><span class="line">        &#123;</span><br><span class="line">            InitCharacterAction();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected abstract void InitCharacterAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>框架的 <code>FR_Character</code> 类只抽取最基本的方法，暂时这样就可以了。<br>这个类不仅是玩家控制的角色要继承的，也可以是地图上 NPC 的父类。</p>
<p>还有一些通用的方法，例如头上显示的心情气泡：</p>
<p><img src="https://pic.imgdb.cn/item/610f96975132923bf8463606.jpg" alt="显示气泡"></p>
<p>不管是 NPC 还是玩家控制的角色都可以显示气泡。<br>这些就是公共方法，可以全部在 <code>FR_Character</code> 中实现，然后子类就可以方便的调用了。</p>
<p>上面只声明了一个初始化方法 <code>InitCharacterAction</code>，实际上的角色类比这个复杂得多，本文只记录开发框架的思想，而不是记录开发框架的具体实现，因此不会把要用的代码全部贴上，只展示部分示例，下文同理。</p>
<h3 id="地图控制器"><a href="#地图控制器" class="headerlink" title="地图控制器"></a>地图控制器</h3><p>角色移动到某张地图的时候，需要判断是否满足条件自动触发剧情，以及更新玩家当前存档所在位置，并且根据是否触发事件来决定是否创建或隐藏角色的节点。这些逻辑的判断就是地图控制器需要做的事情，下面是一个简单的地图抽象类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace FR_Scene</span><br><span class="line">&#123;</span><br><span class="line">    public abstract class FR_Map : MonoBehaviour</span><br><span class="line">    &#123;</span><br><span class="line">        protected string mapName;</span><br><span class="line">        [HideInInspector]</span><br><span class="line">        public FR_MainScene mainScene;</span><br><span class="line">        [HideInInspector]</span><br><span class="line">        public FR_Player player;</span><br><span class="line"></span><br><span class="line">        private void Awake()</span><br><span class="line">        &#123;</span><br><span class="line">            InitMapAction();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void Start()</span><br><span class="line">        &#123;</span><br><span class="line">            OnLoadAction();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected abstract void InitMapAction();</span><br><span class="line">        protected abstract void OnLoadAction();</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 销毁地图</span><br><span class="line">         *&#x2F;</span><br><span class="line">        public abstract void DestroyMap();</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 创建玩家节点</span><br><span class="line">         *&#x2F;</span><br><span class="line">        public abstract FR_Player CreatePlayer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="地图节点"><a href="#地图节点" class="headerlink" title="地图节点"></a>地图节点</h4><p>地图是由一个根节点以及许多个子节点构成的：</p>
<p><img src="https://pic.imgdb.cn/item/610f9b015132923bf85471c1.jpg" alt="地图的节点关系"></p>
<p>假如要控制一个 NPC 的移动，就必须要获得这个节点的对象。<br>原来的做法是在场景中先将 NPC 放在屏幕外面看不见的地方。</p>
<p><img src="https://pic.imgdb.cn/item/610f9b425132923bf85542ee.jpg" alt="地图中的NPC"></p>
<p>地图的脚本里添加几个 <code>GameObject</code> 类型的变量用来保存节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public GameObject npcBaGu, npcMysticMan, npcLouLuo;</span><br></pre></td></tr></table></figure>

<p>然后在 Unity 的面板中，将这些 NPC 逐个拖到组件的变量里。</p>
<p><img src="https://pic.imgdb.cn/item/610f9bbc5132923bf856a884.jpg" alt="组件中的节点"></p>
<p>这样在脚本中就可以用 <code>npcBaGu, npcMysticMan, npcLouLuo</code> 这三个变量来控制节点了。<br>一般的游戏基本都是这么做的，这样做没什么不对，但却有效率上的问题。<br>比如在一个 NPC 很多的地图：</p>
<p><img src="https://pic.imgdb.cn/item/610f9cd05132923bf859df19.jpg" alt="NPC很多的地图"></p>
<p>整个场景就变得乱糟糟的，每一个 NPC 都要单独创建一个节点，而且还必须放到地图里面并且一个个拖到脚本组件上。切换到这个场景的时候，这些节点都会加载到内存里，浪费内存资源不说，时间一长，哪些 NPC 对应哪个剧情都难以分辨，极大的影响开发效率。</p>
<p>为了解决这个问题，地图中的 NPC 节点需要改成动态生成的方式。<br>剧情需要的时候进行创建，不需要的时候就不创建。<br>在创建 NPC 节点的时候，将其加入到 <code>Dictionary&lt;string, GameObject&gt;</code>（字典）中。<br>这样地图控制器就能通过节点名称来获取到地图中指定节点。</p>
<h5 id="NPC-节点"><a href="#NPC-节点" class="headerlink" title="NPC 节点"></a>NPC 节点</h5><p>这里又有新的问题，如果每一个 NPC 节点都做成 Prefab（预制体），那么当 NPC 多了起来又会无法分辨哪个是哪个。我不希望一个文件夹里存放着成百上千个 NPC 的预制体，因为这样会增加项目的管理难度。</p>
<p>NPC 节点真的需要单独创建吗？<br>仔细想想的话，每一个 NPC 其实都存在许多共通的部分。<br>比如每一个 NPC 都有行走图，都有移动的方法，玩家与 NPC 接触时，按下调查键都可以进行对话。</p>
<p>这样就可以把 NPC 节点的公共部分抽取出来，子类只需要单独编写特有的事件处理即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace FR_Scene</span><br><span class="line">&#123;</span><br><span class="line">    public abstract class FR_Character : MonoBehaviour</span><br><span class="line">    &#123;</span><br><span class="line">        private void Awake()</span><br><span class="line">        &#123;</span><br><span class="line">            InitCharacterAction();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected abstract void InitCharacterAction();</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 设置位置（本地坐标）</span><br><span class="line">         *&#x2F;</span><br><span class="line">        public void SetLocalePosition(float x, float y, float scaleX &#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            Vector3 pos &#x3D; transform.position;</span><br><span class="line">            pos.x &#x3D; x;</span><br><span class="line">            pos.y &#x3D; y;</span><br><span class="line">            transform.position &#x3D; pos;</span><br><span class="line"></span><br><span class="line">            if (scaleX !&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                SetLocalScale(scaleX);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void SetLocalScale(float x, float y &#x3D; 1)</span><br><span class="line">        &#123;</span><br><span class="line">            Vector3 scale &#x3D; transform.localScale;</span><br><span class="line">            scale.x &#x3D; x;</span><br><span class="line">            scale.y &#x3D; y;</span><br><span class="line"></span><br><span class="line">            transform.localScale &#x3D; scale;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是一个简单的例子，里面包含了设置节点坐标和朝向的方法。</p>
<h5 id="角色节点"><a href="#角色节点" class="headerlink" title="角色节点"></a>角色节点</h5><p>同样地，玩家控制的角色节点，也需要封装一个抽象类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line"></span><br><span class="line">namespace FR_Scene &#123;</span><br><span class="line">    public abstract class FR_Player : FR_Character</span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前创建这样一个空壳就可以了。</p>
<h5 id="在游戏中调用"><a href="#在游戏中调用" class="headerlink" title="在游戏中调用"></a>在游戏中调用</h5><p>创建一个简易的测试地图：</p>
<p><img src="https://pic.imgdb.cn/item/6111f2265132923bf8bfbf70.jpg" alt="测试地图"></p>
<p>然后将地图节点拖到 Resources 目录做成预制体：</p>
<p><img src="https://pic.imgdb.cn/item/6111f7eb5132923bf8c972d4.jpg" alt="地图预制体"></p>
<p>因为是重构的系统，为了避免与原来的代码产生冲突，我新建了一个 <code>Reactor</code> 文件夹用来存放使用框架的代码。</p>
<p><img src="https://pic.imgdb.cn/item/6111f24e5132923bf8bfffa7.jpg" alt="新系统的代码"></p>
<p>分别创建三个类：<code>AbstractMap</code>、<code>MainScene</code>、<code>PlayerCharacter</code>。</p>
<p><code>AbstractMap</code> 类是游戏中实际地图的基类，包含了地图需要用的基本方法。如获取角色所在图层以及创建玩家节点和销毁地图的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using FR_Scene;</span><br><span class="line"></span><br><span class="line">namespace Refactor.Scene</span><br><span class="line">&#123;</span><br><span class="line">    public abstract class AbstractMap : FR_Map</span><br><span class="line">    &#123;</span><br><span class="line">        protected Transform characterDiv;</span><br><span class="line"></span><br><span class="line">        protected override void InitMapAction()</span><br><span class="line">        &#123;</span><br><span class="line">            characterDiv &#x3D; transform.Find(&quot;Div_3&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public override void DestroyMap()</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(gameObject);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public override FR_Player CreatePlayer()</span><br><span class="line">        &#123;</span><br><span class="line">            string path &#x3D; &quot;Prefabs&#x2F;Character&#x2F;PlayerCharacter&quot;;</span><br><span class="line">            GameObject prefab &#x3D; Resources.Load(path) as GameObject;</span><br><span class="line">            GameObject obj &#x3D; Instantiate(prefab, characterDiv);</span><br><span class="line"></span><br><span class="line">            player &#x3D; obj.GetComponent&lt;PlayerCharacter&gt;();</span><br><span class="line"></span><br><span class="line">            return player;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MainScene</code> 类是主场景类，继承框架的主场景同时编写一些游戏特有的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace Refactor.Scene</span><br><span class="line">&#123;</span><br><span class="line">    public class MainScene : FR_Scene.FR_MainScene</span><br><span class="line">    &#123;</span><br><span class="line">        [HideInInspector]</span><br><span class="line">        public AbstractMap currentMap;</span><br><span class="line">        [HideInInspector]</span><br><span class="line">        public GameObject mainCamera;</span><br><span class="line"></span><br><span class="line">        protected override void InitMainSceneAction()</span><br><span class="line">        &#123;</span><br><span class="line">            LocaleManager.LoadLocaleSetting();</span><br><span class="line">            mainCamera &#x3D; GameObject.FindWithTag(&quot;MainCamera&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected override void OnLoadAction()</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public override void LoadMap(string mapName, Action callback &#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            if (currentMap !&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                currentMap.DestroyMap();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            GameObject prefab &#x3D; Resources.Load(&quot;Prefabs&#x2F;Map&#x2F;&quot; + mapName) as GameObject;</span><br><span class="line">            GameObject obj &#x3D; Instantiate(prefab);</span><br><span class="line">            currentMap &#x3D; obj.GetComponent&lt;AbstractMap&gt;();</span><br><span class="line">            currentMap.mainScene &#x3D; this;</span><br><span class="line"></span><br><span class="line">            if (callback !&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                callback();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如在 <code>InitMainSceneAction</code> 方法中，初始化本地语言配置文件以及获得当前场景的摄像机节点；<code>LoadMap</code> 是加载地图的方法，这里只进行简单的实现。</p>
<p><code>PlayerCharacter</code> 就是玩家控制的角色节点的逻辑处理类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace Refactor</span><br><span class="line">&#123;</span><br><span class="line">    public class PlayerCharacter : FR_Scene.FR_Player</span><br><span class="line">    &#123;</span><br><span class="line">        public float moveSpeed &#x3D; 3.8f;</span><br><span class="line"></span><br><span class="line">        private Rigidbody2D rb;</span><br><span class="line">        private float horizontal;</span><br><span class="line"></span><br><span class="line">        private Vector3 originalLocalScale;</span><br><span class="line"></span><br><span class="line">        protected override void InitCharacterAction()</span><br><span class="line">        &#123;</span><br><span class="line">            rb &#x3D; GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">            originalLocalScale &#x3D; transform.localScale;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void Update()</span><br><span class="line">        &#123;</span><br><span class="line">            horizontal &#x3D; Input.GetAxisRaw(&quot;Horizontal&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void FixedUpdate()</span><br><span class="line">        &#123;</span><br><span class="line">            rb.velocity &#x3D; new Vector2(horizontal * moveSpeed, 0);</span><br><span class="line"></span><br><span class="line">            if (horizontal !&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                float scaleX &#x3D; horizontal &gt; 0 ? originalLocalScale.x : -1 * originalLocalScale.x;</span><br><span class="line">                SetLocalScale(scaleX);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面实现了简单的控制移动。</p>
<p><img src="https://pic.imgdb.cn/item/6111f4325132923bf8c3444d.gif" alt="角色的移动"></p>
<p>现在做的事情跟原来没什么不同，还花了那么多时间来修改代码，这样做的意义何在？<br>其实主要还是为了规范化的开发，而且现在的演示也没法体现出框架的好处，越往后开发框架的优点才越清晰。</p>
<h5 id="游戏对象建造器"><a href="#游戏对象建造器" class="headerlink" title="游戏对象建造器"></a>游戏对象建造器</h5><p>上面的代码中，直接调用 Unity 的实例化方法创建节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 生成角色节点</span><br><span class="line">public override FR_Player CreatePlayer()</span><br><span class="line">&#123;</span><br><span class="line">    string path &#x3D; &quot;Prefabs&#x2F;Character&#x2F;PlayerCharacter&quot;;</span><br><span class="line">    GameObject prefab &#x3D; Resources.Load(path) as GameObject;</span><br><span class="line">    GameObject obj &#x3D; Instantiate(prefab, characterDiv);</span><br><span class="line"></span><br><span class="line">    player &#x3D; obj.GetComponent&lt;PlayerCharacter&gt;();</span><br><span class="line"></span><br><span class="line">    return player;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 生成地图节点</span><br><span class="line">public override void LoadMap(string mapName, Action callback &#x3D; null)</span><br><span class="line">&#123;</span><br><span class="line">    if (currentMap !&#x3D; null)</span><br><span class="line">    &#123;</span><br><span class="line">        currentMap.DestroyMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GameObject prefab &#x3D; Resources.Load(&quot;Prefabs&#x2F;Map&#x2F;&quot; + mapName) as GameObject;</span><br><span class="line">    GameObject obj &#x3D; Instantiate(prefab);</span><br><span class="line">    currentMap &#x3D; obj.GetComponent&lt;AbstractMap&gt;();</span><br><span class="line">    currentMap.mainScene &#x3D; this;</span><br><span class="line"></span><br><span class="line">    if (callback !&#x3D; null)</span><br><span class="line">    &#123;</span><br><span class="line">        callback();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建游戏节点（GameObject）的时候发现了“冗余”的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GameObject prefab &#x3D; Resources.Load(&quot;Prefabs&#x2F;Map&#x2F;&quot; + mapName) as GameObject;</span><br><span class="line">GameObject obj &#x3D; Instantiate(prefab);</span><br><span class="line">currentMap &#x3D; obj.GetComponent&lt;AbstractMap&gt;();</span><br></pre></td></tr></table></figure>

<p>在加载动态资源的时候要用到 <code>Resources.Load</code>，然后又要实例化预制体要用到 <code>Instantiate</code>……这个过程非常繁琐，而且还都是重复性劳动，对于开发体验极其不友好。</p>
<p>框架的作用就体现出来了，只要封装一个专门用来“生成节点”的类就好了。<br>创建一个专门用来生成游戏对象的类 <code>FR_ObjectBuilder</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace FR_Builder</span><br><span class="line">&#123;</span><br><span class="line">    public class FR_ObjectBuilder : MonoBehaviour</span><br><span class="line">    &#123;</span><br><span class="line">        public static GameObject Generate(string prefabPath, Transform parentTrans &#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            GameObject prefab &#x3D; Resources.Load&lt;GameObject&gt;(prefabPath);</span><br><span class="line"></span><br><span class="line">            return Generate(prefab, parentTrans);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static GameObject Generate(GameObject prefab, Transform parentTrans &#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            GameObject obj &#x3D; Instantiate(prefab);</span><br><span class="line"></span><br><span class="line">            if (parentTrans !&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                obj.transform.SetParent(parentTrans);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后上面创建地图和创建角色对象的方法就可以简化为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建地图</span><br><span class="line">public override void LoadMap(string mapName, Action callback &#x3D; null)</span><br><span class="line">&#123;</span><br><span class="line">    if (currentMap !&#x3D; null)</span><br><span class="line">    &#123;</span><br><span class="line">        currentMap.DestroyMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GameObject obj &#x3D; FR_Builder.FR_ObjectBuilder.Generate(&quot;Prefabs&#x2F;Map&#x2F;&quot; + mapName);</span><br><span class="line">    currentMap &#x3D; obj.GetComponent&lt;AbstractMap&gt;();</span><br><span class="line">    currentMap.mainScene &#x3D; this;</span><br><span class="line"></span><br><span class="line">    if (callback !&#x3D; null)</span><br><span class="line">    &#123;</span><br><span class="line">        callback();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建角色节点</span><br><span class="line">public override FR_Player CreatePlayer()</span><br><span class="line">&#123;</span><br><span class="line">    string path &#x3D; &quot;Prefabs&#x2F;Character&#x2F;PlayerCharacter&quot;;</span><br><span class="line">    GameObject obj &#x3D; FR_Builder.FR_ObjectBuilder.Generate(path);</span><br><span class="line"></span><br><span class="line">    player &#x3D; obj.GetComponent&lt;PlayerCharacter&gt;();</span><br><span class="line"></span><br><span class="line">    return player;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="角色节点生成器"><a href="#角色节点生成器" class="headerlink" title="角色节点生成器"></a>角色节点生成器</h5><p>地图中的 NPC 以及玩家控制的主角，都叫做角色节点，本质都是同一种类型的节点。<br>只是它们的控制逻辑不同，玩家角色需要玩家输入键盘指令来控制移动，NPC 则是由系统 AI 控制。</p>
<p>可以把角色节点想象为一团橡皮泥，刚开始的时候是一团不知道什么类型的泥。<br>如果要捏一个 NPC，就捏出 NPC 的形状；如果要捏一个主角，就捏出主角的形状。<br>它们最开始都是 <code>FR_Character</code> 类型的，它们都有获取精灵和动画组件的方法，再根据需要在子类编写特有的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public abstract class FR_Character : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    private SpriteRenderer walkingGraphRenderer;</span><br><span class="line">    private Animator animator;</span><br><span class="line"></span><br><span class="line">    private void Awake()</span><br><span class="line">    &#123;</span><br><span class="line">        walkingGraphRenderer &#x3D; GetComponent&lt;SpriteRenderer&gt;();</span><br><span class="line">        animator &#x3D; GetComponent&lt;Animator&gt;();</span><br><span class="line"></span><br><span class="line">        InitCharacterAction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void SetWalkingGraphSprite(Sprite sprite)</span><br><span class="line">    &#123;</span><br><span class="line">        walkingGraphRenderer.sprite &#x3D; sprite;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 省略其他方法……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FR_Character</code> 类定义了一团“橡皮泥”，它没有任何“形状”，它提供了一个 <code>SetWalkingGraphSprite</code> 方法用于实现“变形功能”（替换行走图）。</p>
<p>接着为 <code>FR_Map</code> 类添加生成 NPC 节点的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义一个字典用于保存场景中的NPC节点</span><br><span class="line">private Dictionary&lt;string, GameObject&gt; npcs &#x3D; new Dictionary&lt;string, GameObject&gt;();</span><br><span class="line"></span><br><span class="line">public GameObject CreateNPC(FR_Data.CharacterData data)</span><br><span class="line">&#123;</span><br><span class="line">    GameObject obj &#x3D; new GameObject();</span><br><span class="line"></span><br><span class="line">    obj.name &#x3D; data.name;</span><br><span class="line">    SpriteRenderer spriteRenderer &#x3D; obj.AddComponent&lt;SpriteRenderer&gt;();</span><br><span class="line">    spriteRenderer.sprite &#x3D; Resources.Load&lt;Sprite&gt;(data.walkingGraphPath);</span><br><span class="line">    spriteRenderer.sortingOrder &#x3D; data.sorting;</span><br><span class="line"></span><br><span class="line">    npcs.Add(data.name, obj);</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>GameObject</code> 是 Unity 所有游戏对象的基类，也就是创建一团空白的橡皮泥。<br>要用橡皮泥捏出一个形状，可以是小动物、也可以是人，也可以是建筑物……<br>它们的区别就在于形状和大小、颜色，这些就是“参数”。<br>在创建 NPC 的时候，需要传入 NPC 的行走图、位置等等参数，这样就可以根据参数“定制”出一个 NPC：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace FR_Data</span><br><span class="line">&#123;</span><br><span class="line">    public class CharacterData</span><br><span class="line">    &#123;</span><br><span class="line">        public string name;</span><br><span class="line">        public string walkingGraphPath;</span><br><span class="line">        public int sorting;</span><br><span class="line">        public Vector3 localePosition;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; …… 还可以定义更加详细的参数，如缩放等等</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在游戏地图的方法中测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CreateNPC(new FR_Data.CharacterData</span><br><span class="line">            &#123;</span><br><span class="line">                name &#x3D; &quot;npc_1&quot;,</span><br><span class="line">                walkingGraphPath &#x3D; &quot;Sprites&#x2F;WalkingGraph&#x2F;xiaoxing&quot;,</span><br><span class="line">                sorting &#x3D; 300,</span><br><span class="line">                localePosition &#x3D; new Vector3(0, -1.35f),</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>

<p>通过继承得到了 <code>CreateNPC</code> 方法，传入基本的参数。<br>运行游戏测试：</p>
<p><img src="https://pic.imgdb.cn/item/611287ba5132923bf8e87721.jpg" alt="动态创建NPC"></p>
<p>可以看到左上角的节点树多了一个 <code>npc_1</code> 的节点，就是动态创建的 NPC。<br>虽然节点可以存在重名，但是需要人为的避免重名的情况，因为这样不利于查找节点。</p>
<p>现在，框架已经提供了一个可以动态创建 NPC 的方法，NPC 由脚本控制而不需要在地图中手动添加。<br>而且创建 NPC 的节点不依赖任何 Prefab（预制体），仅需要提供 <code>FR_Data.CharacterData</code> 参数即可。</p>
<p>如此一来，节省了手动创建节点的时间，而且地图中也会变得非常干净。<br>但是缺点就是没有运行游戏的话，就不知道 NPC 会出现在哪里，总体而言是利大于弊的。</p>
<h5 id="查询节点"><a href="#查询节点" class="headerlink" title="查询节点"></a>查询节点</h5><p>在调用 <code>CreateNPC</code> 创建节点的时候，已经将节点的对象添加到 <code>Dictionary&lt;string, GameObject&gt; npcs</code> 字典里了。查找地图中的某个 NPC 只需要知道 NPC 的名字就可以直接获得。</p>
<p>查询节点是剧情动画中必不可少的一个功能，比如控制地图中哪个 NPC 走动，只要知道名字就能直接拿到对应的 NPC，非常方便。</p>
<h4 id="自动加载事件"><a href="#自动加载事件" class="headerlink" title="自动加载事件"></a>自动加载事件</h4><p>事件的处理包括：</p>
<ul>
<li>事件条件的判断</li>
<li>事件内容的处理</li>
</ul>
<p>首先判断事件的条件是否成立，比如玩家切换到地图的时候，要自动进入一段剧情事件，然后下一次再回到这个地图，这个事件就不应该继续再执行了。也就是说，第一次切换到地图的时候，因为还没执行过事件，就执行一次，然后设置一个标志证明已经执行过事件了，下次回到这个地图，判断是否存在这个标志，如果有这个标志就不进行处理。</p>
<p>这个标志即事件的触发条件，比如一个开关，一个变量，都可以作为事件的条件判断依据。<br>判断依据是游戏中特有的逻辑，需要单独实现，框架只提供一个抽象类用于继承。</p>
<h5 id="事件触发器"><a href="#事件触发器" class="headerlink" title="事件触发器"></a>事件触发器</h5><p>事件触发器是通用的，不仅仅只是用来做地图自动触发事件的判断，它可以用在任何需要进行条件判断的地方。<br>它的作用有点类似状态机，但是实现原理与状态机不同。</p>
<p>触发器的作用相当于 <code>if</code> 结构，即如果……就……。对于事件的判断用 <code>if</code> 结构肯定没问题，但是游戏的剧情逻辑十分复杂，用 <code>if</code> 来处理就不实际了，通俗的讲事件触发器就是比较高级的 <code>if</code> 判断语句。</p>
<p>事件触发器如果用可视化的界面比喻就是 RPG Maker 系列了的“事件页”系统：</p>
<p><img src="https://pic.imgdb.cn/item/610fb72c5132923bf89e9528.jpg" alt="RPG Maker 事件页"></p>
<p>当满足左上角设置的开关、独立开关以及变量的条件，事件就会显示当前页的逻辑处理。</p>
<blockquote>
<p>RPG Maker 的事件页里还可以再添加条件判断语句来执行更加细致的条件判断，如上面的“条件分歧”。</p>
</blockquote>
<p>事件页模式有一个缺点就是只能单向处理事件。比如有 A、B、C 三个事件，首先触发器的逻辑会从最后一页开始判断，当满足 C 的条件时，就不再继续判断 B 和 A 的条件，而是开始执行 C 的逻辑处理。通常在处理完 C 的事件后，会再添加一个空白的 D 事件，在 C 事件处理完成之后就不再执行。</p>
<p>比如有一个宝箱，打开之后得到一些金钱，玩家打开宝箱后就要开启一个独立开关，增加一个空白页防止无限获得金钱。</p>
<p>这样就存在一个问题——无法返回前置的事件，因为 C 事件执行完之后就已经打开了 D 事件的开关，下次重新载入这个事件也只能执行 D 事件，无法回头执行 A、B 事件。</p>
<p>典型的例子就是当玩家同时完成两个任务，而任务的委托人是同一个 NPC，这样在提交完其中一个任务，另一个任务就无法提交了。<br>为了避免这种情况，我改进了这种单向的事件页模式。</p>
<p>添加新的命名空间 <code>FR_Trigger</code> 用来管理事件触发器类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace FR_Trigger</span><br><span class="line">&#123;</span><br><span class="line">    public class FR_TriggerManager</span><br><span class="line">    &#123;</span><br><span class="line">        protected static List&lt;FR_TriggerEventContainer&gt; containers &#x3D; new List&lt;FR_TriggerEventContainer&gt;();</span><br><span class="line">        protected static bool isHandle;</span><br><span class="line"></span><br><span class="line">        public static FR_TriggerEventContainer CreateContainer()</span><br><span class="line">        &#123;</span><br><span class="line">            FR_TriggerEventContainer container &#x3D; new FR_TriggerEventContainer();</span><br><span class="line">            containers.Add(container);</span><br><span class="line"></span><br><span class="line">            return container;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static void Handle()</span><br><span class="line">        &#123;</span><br><span class="line">            if (isHandle) return;</span><br><span class="line"></span><br><span class="line">            foreach (var container in containers)</span><br><span class="line">            &#123;</span><br><span class="line">                var data &#x3D; container.GetSatisfiedPage();</span><br><span class="line">                if (data !&#x3D; null)</span><br><span class="line">                &#123;</span><br><span class="line">                    isHandle &#x3D; true;</span><br><span class="line">                    data.HandleEvent();</span><br><span class="line"></span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进的事件页模式增加了容器的概念，通过 <code>CreateContainer</code> 来创建一个新的事件容器，一个事件容器就是 RPG Maker 的一个事件（包含多页），容器存在执行顺序，当满足了第一个容器之后就不会再执行其他容器事件，避免多个容器的事件被同时执行。</p>
<h5 id="事件容器"><a href="#事件容器" class="headerlink" title="事件容器"></a>事件容器</h5><p>事件容器存储了多页事件的触发条件以及对应的事件处理，相当于 RPG Maker 里的一个“事件”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace FR_Trigger</span><br><span class="line">&#123;</span><br><span class="line">    public class FR_TriggerEventContainer</span><br><span class="line">    &#123;</span><br><span class="line">        public List&lt;FR_TriggerEventPage&gt; pages &#x3D; new List&lt;FR_TriggerEventPage&gt;();</span><br><span class="line"></span><br><span class="line">        public FR_TriggerEventContainer AddTriggerEvent(FR_TriggerEventPage eventData)</span><br><span class="line">        &#123;</span><br><span class="line">            pages.Add(eventData);</span><br><span class="line"></span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public FR_TriggerEventPage GetSatisfiedPage()</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i &#x3D; pages.Count - 1; i &gt; 0; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                if (pages[i].Check())</span><br><span class="line">                &#123;</span><br><span class="line">                    return pages[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单页事件的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace FR_Trigger</span><br><span class="line">&#123;</span><br><span class="line">    public class FR_TriggerEventPage</span><br><span class="line">    &#123;</span><br><span class="line">        public List&lt;FR_TriggerConditionAbstract&gt; conditionAbstracts;</span><br><span class="line">        public FR_TriggerEvent triggerEvent;</span><br><span class="line"></span><br><span class="line">        public bool Check()</span><br><span class="line">        &#123;</span><br><span class="line">            foreach (var condition in conditionAbstracts)</span><br><span class="line">            &#123;</span><br><span class="line">                if (condition.Check() &#x3D;&#x3D; false) return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void HandleEvent()</span><br><span class="line">        &#123;</span><br><span class="line">            triggerEvent.Success();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="事件触发条件"><a href="#事件触发条件" class="headerlink" title="事件触发条件"></a>事件触发条件</h5><p>触发条件是一个抽象类，子类只要继承此类，然后实现一个 <code>Check</code> 检验条件是否成立即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace FR_Trigger</span><br><span class="line">&#123;</span><br><span class="line">    public abstract class FR_TriggerConditionAbstract : MonoBehaviour</span><br><span class="line">    &#123;</span><br><span class="line">        public abstract bool Check();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="抽象事件类"><a href="#抽象事件类" class="headerlink" title="抽象事件类"></a>抽象事件类</h5><p>框架只需要封装一个标准的事件类，具体的处理要在游戏实际的场景编写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace FR_Trigger</span><br><span class="line">&#123;</span><br><span class="line">    public class FR_TriggerEvent : MonoBehaviour</span><br><span class="line">    &#123;</span><br><span class="line">        protected System.Action successAction;</span><br><span class="line"></span><br><span class="line">        public FR_TriggerEvent(System.Action successAction &#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            this.successAction &#x3D; successAction;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void Success()</span><br><span class="line">        &#123;</span><br><span class="line">            if (successAction &#x3D;&#x3D; null) return;</span><br><span class="line"></span><br><span class="line">            successAction();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事件页包含了成功时的处理方法以及构造函数用于给方法赋值。</p>
<h4 id="NPC-事件"><a href="#NPC-事件" class="headerlink" title="NPC 事件"></a>NPC 事件</h4><p>NPC 事件与地图的自动触发事件原理一样，只是触发的时机不同。<br>地图自动触发事件是在地图加载时就进行判断，而 NPC 事件则是玩家走到 NPC 面前，按下调查键才会触发的。</p>
<h4 id="剧情演出系统"><a href="#剧情演出系统" class="headerlink" title="剧情演出系统"></a>剧情演出系统</h4><p>一段剧情由很多个「事件动作」组成，例如控制 NPC 移动，然后弹出对话。NPC 说完话后离开场景，接着又轮到玩家控制的角色说话……诸如此类。剧情演出系统是由一连串的动作组成，这些动作的具体实现是子类要做的事情，框架只需要提供一个可以触发剧情演出的管理器即可。</p>
<p>关于剧情演出系统，在上一篇文章已经实现了：<a href="https://huotuyouxi.com/2021/08/06/game-maker-001/">如何优雅的控制游戏中的剧情事件？</a></p>
<p>剧情演出系统由三个部分构成：</p>
<ul>
<li>剧情演出管理器</li>
<li>事件容器</li>
<li>事件动作</li>
</ul>
<h5 id="管理器"><a href="#管理器" class="headerlink" title="管理器"></a>管理器</h5><p>管理器负责调用事件容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line"></span><br><span class="line">namespace FR_Event</span><br><span class="line">&#123;</span><br><span class="line">    public class EventManager : MonoBehaviour</span><br><span class="line">    &#123;</span><br><span class="line">        public static EventContainer eventContainer;</span><br><span class="line"></span><br><span class="line">        public static EventContainer StartNewQueue()</span><br><span class="line">        &#123;</span><br><span class="line">            eventContainer &#x3D; new EventContainer();</span><br><span class="line">            return eventContainer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="事件容器-1"><a href="#事件容器-1" class="headerlink" title="事件容器"></a>事件容器</h5><p>事件容器负责存储事件动作以及执行当前动作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace FR_Event</span><br><span class="line">&#123;</span><br><span class="line">    public class EventContainer</span><br><span class="line">    &#123;</span><br><span class="line">        public Queue&lt;EventActionAbstract&gt; queue &#x3D; new Queue&lt;EventActionAbstract&gt;();</span><br><span class="line"></span><br><span class="line">        public EventContainer Append(EventActionAbstract eventAction)</span><br><span class="line">        &#123;</span><br><span class="line">            queue.Enqueue(eventAction);</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void StartEvent()</span><br><span class="line">        &#123;</span><br><span class="line">            if (queue.Count &#x3D;&#x3D; 0) return;</span><br><span class="line"></span><br><span class="line">            var current &#x3D; queue.Dequeue();</span><br><span class="line">            current.Handle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="抽象事件动作"><a href="#抽象事件动作" class="headerlink" title="抽象事件动作"></a>抽象事件动作</h5><p>最后抽象出事件动作，提供一个父类让游戏的实际使用场景继承：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">namespace FR_Event</span><br><span class="line">&#123;</span><br><span class="line">    public abstract class EventActionAbstract</span><br><span class="line">    &#123;</span><br><span class="line">        protected void EventEnd()</span><br><span class="line">        &#123;</span><br><span class="line">            FR_Event.EventManager.eventContainer.StartEvent();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public abstract void Handle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="文件规范"><a href="#文件规范" class="headerlink" title="文件规范"></a>文件规范</h5><p>上一篇文章是把事件动作的具体实现放到框架的文件夹里：</p>
<p><img src="https://pic.imgdb.cn/item/610f99965132923bf8500b27.jpg" alt="事件动作所在目录"></p>
<p>但是为了与游戏逻辑解耦，需要移除这个文件夹，并放到游戏的脚本目录里：</p>
<p><img src="https://pic.imgdb.cn/item/610f9a015132923bf8514a7a.jpg" alt="新建存放事件动作的文件夹"></p>
<p>框架的代码不能包含当前游戏的相关逻辑，这样以后才可以抽取出来用在不同的游戏里。</p>
<p>完成之后，剧情的演出系统就可以通过如下这种链式调用来组织一段剧情的演出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FR_Event.EventManager</span><br><span class="line">         .StartNewQueue()</span><br><span class="line">         .Append(new DialogAction(&quot;00_test&#x2F;01_text&quot;))</span><br><span class="line">         .Append(new DialogAction(&quot;00_test&#x2F;02_text&quot;))</span><br><span class="line">         .StartEvent();</span><br></pre></td></tr></table></figure>

<h2 id="场景系统结构图"><a href="#场景系统结构图" class="headerlink" title="场景系统结构图"></a>场景系统结构图</h2><p>大致的组织结构图如下：</p>
<p><img src="https://pic.imgdb.cn/item/6112904f5132923bf8fccccd.jpg" alt="场景系统结构图"></p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>目前的框架只是一个基本的雏形，而且后面的大都是理论没有实际测试。我打算把原来做好的部分逐步替换为新框架，根据实际使用的情况来完善这个框架。</p>
<p>PS.这里发现了自己命名也是不规范的，加上 <code>namespace</code>（命名空间）后，文件和类的名字就不用再加上 <code>FR_</code> 的前缀了，但是因为担心和游戏实际代码的类混淆，所以有时候会加上前缀，有时候又忘了加……总的来说，就算是同一个人写的代码，要保持相同的风格也是不靠谱的……</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">火烧兔子</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://huotuyouxi.com/2021/08/10/monster-game-12/">http://huotuyouxi.com/2021/08/10/monster-game-12/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://huotuyouxi.com">火兔游戏工作室</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/">开发技术</a><a class="post-meta__tags" href="/tags/unity/">unity</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/08/13/monster-game-13/"><i class="fa fa-chevron-left">  </i><span>《名为怪物的游戏》框架开发篇（素材的处理）</span></a></div><div class="next-post pull-right"><a href="/2021/08/07/future-001/"><span>关于未来的开发计划</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2021/05/02/61DLs9VHetxbq2n.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2023 By 火烧兔子</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>