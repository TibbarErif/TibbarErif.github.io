<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="【Unity小技巧】如何优雅的控制游戏中的剧情事件？"><meta name="keywords" content="开发技术,unity"><meta name="author" content="火烧兔子"><meta name="copyright" content="火烧兔子"><title>【Unity小技巧】如何优雅的控制游戏中的剧情事件？ | 火兔游戏工作室</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-6777753891073316',
  enable_page_level_ads: 'true'
});
</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%9F%E7%B3%95%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">2.</span> <span class="toc-text">糟糕的代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A5%9E%E7%A7%98%E4%BA%BA%E8%B5%B0%E8%BF%87%E6%9D%A5"><span class="toc-number">2.1.</span> <span class="toc-text">神秘人走过来</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E7%AC%AC%E4%B8%80%E6%AE%B5%E5%AF%B9%E8%AF%9D"><span class="toc-number">2.2.</span> <span class="toc-text">触发第一段对话</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A5%9E%E7%A7%98%E4%BA%BA%E7%A7%BB%E5%8A%A8%E5%88%B0%E6%A4%85%E5%AD%90%E9%82%A3%E8%BE%B9"><span class="toc-number">2.3.</span> <span class="toc-text">神秘人移动到椅子那边</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E7%AC%AC%E4%BA%8C%E6%AE%B5%E5%AF%B9%E8%AF%9D"><span class="toc-number">2.4.</span> <span class="toc-text">触发第二段对话</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%88%90%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">2.5.</span> <span class="toc-text">完成后的代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">数据结构与设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">3.1.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">3.2.</span> <span class="toc-text">链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">数据结构有什么用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88"><span class="toc-number">3.4.</span> <span class="toc-text">队列和栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">设计模式是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%A7%E6%83%85%E4%BA%8B%E4%BB%B6%E4%BC%98%E5%8C%96"><span class="toc-number">4.</span> <span class="toc-text">剧情事件优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text">链式调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-number">4.2.</span> <span class="toc-text">事件处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E8%A8%80"><span class="toc-number">5.</span> <span class="toc-text">后言</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://i.loli.net/2021/05/02/JjR7MmfePax3oc2.jpg"></div><div class="author-info__name text-center">火烧兔子</div><div class="author-info__description text-center">我的世界，在你手中。</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">157</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">44</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">30</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2021/05/02/61DLs9VHetxbq2n.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">火兔游戏工作室</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/archives">归档</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">【Unity小技巧】如何优雅的控制游戏中的剧情事件？</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-06</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/">小技巧</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本次尝试更新一篇技术型的文档，目的也是为了记录自己学习的过程。<br>游戏开发与普通开发不一样的地方在于逻辑的处理比较复杂。<br>如果没有一个良好的架构设计，处理游戏逻辑的代码就会看起来乱糟糟的。</p>
<h2 id="糟糕的代码"><a href="#糟糕的代码" class="headerlink" title="糟糕的代码"></a>糟糕的代码</h2><p>这是在写这篇文档之前，《名为怪物的游戏》中处理场景事件的代码。<br>在火车逃亡篇中，有这样一段剧情：</p>
<p><img src="https://files.catbox.moe/f20zr5.gif" alt="巴古与神秘人的交易"></p>
<p>这个剧情事件一共分为如下几个步骤：</p>
<ul>
<li>神秘人走过来</li>
<li>开始第一段对话</li>
<li>神秘人走到旁边的椅子</li>
<li>开始第二段对话</li>
</ul>
<p>这是游戏剧情中很常见的操作，控制场景 NPC 执行移动事件，然后触发对话。<br>但是要控制这样一连串的行为，用代码如何实现呢？</p>
<p>在通常情况下，代码是从上至下执行的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Debug.Log(&quot;aa&quot;);</span><br><span class="line">Debug.Log(&quot;bb&quot;);</span><br></pre></td></tr></table></figure>

<p>比如上述的代码片段，首先打印出 <code>aa</code>，然后才打印出 <code>bb</code>；<br>这是由于打印 <code>aa</code> 的语句写在前面，所以先执行了，如果交换一下顺序，输出的顺序也会跟着改变。</p>
<p>这也是程序开发中很寻常的书写方法，那么如果游戏开发也用这种方法，会怎么样呢？</p>
<p>下面是我用来实现上述剧情事件的代码。</p>
<h3 id="神秘人走过来"><a href="#神秘人走过来" class="headerlink" title="神秘人走过来"></a>神秘人走过来</h3><p>由于神秘人最开始是看不见的，所以把神秘人放到屏幕外面，不仅是神秘人，还有巴古以及后续登场的小喽喽都放在屏幕外面（玩家看不见的地方）。</p>
<p><img src="https://files.catbox.moe/s2iepm.jpg" alt="场景中的NPC"></p>
<p>当玩家进入当前场景的时候，事件就开始执行了。<br>首先是设置登场 NPC 的坐标和朝向。</p>
<p>例如，下面是控制神秘人移动的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MapManager.SetTargetLocalPosition(npcMysticMan, 7.08f, -0.62f, Direct.LEFT);</span><br><span class="line"></span><br><span class="line">iTween.MoveTo(npcMysticMan, new Hashtable</span><br><span class="line">&#123;</span><br><span class="line">    &#123; &quot;x&quot;, 1.37f &#125;,</span><br><span class="line">    &#123; &quot;isLocal&quot;, true &#125;,</span><br><span class="line">    &#123; &quot;easeType&quot;, iTween.EaseType.linear &#125;,</span><br><span class="line">    &#123; &quot;onComplete&quot;, &quot;Trade&quot; &#125;,</span><br><span class="line">    &#123; &quot;onCompleteTarget&quot;, gameObject &#125;,</span><br><span class="line">    &#123; &quot;time&quot;, 2f &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码使用了第三方插件 Itween 来控制目标的移动。<br>因为没有行走图只是单纯的移动坐标，所以角色看起来像是飘过来。</p>
<p><img src="https://files.catbox.moe/lesfxz.gif" alt="神秘人移动事件"></p>
<h3 id="触发第一段对话"><a href="#触发第一段对话" class="headerlink" title="触发第一段对话"></a>触发第一段对话</h3><p>神秘人移动结束之后，就要触发第一段对话。<br>这里需要使用 Itween 插件的回调方法 <code>onComplete</code> 来执行。</p>
<p>Itween 插件可以很方便的控制物体移动，并且在移动结束后执行设置好的回调方法。<br>编写移动结束时的回调方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void Trade()</span><br><span class="line">&#123;</span><br><span class="line">    WindowManager.CallDialog(&quot;06_bagu_room&#x2F;02_trade&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，神秘人移动到指定位置后就会触发第一段对话了，如下。</p>
<p><img src="https://files.catbox.moe/d230tx.gif" alt="第一段对话"></p>
<h3 id="神秘人移动到椅子那边"><a href="#神秘人移动到椅子那边" class="headerlink" title="神秘人移动到椅子那边"></a>神秘人移动到椅子那边</h3><p>对话结束后，神秘人要移动到椅子那边。<br>这里用到我自己设计的对话完成后回调的方法。</p>
<p>修改对话方法，添加移动事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void Trade()</span><br><span class="line">&#123;</span><br><span class="line">    WindowManager.CallDialog(&quot;06_bagu_room&#x2F;02_trade&quot;, delegate</span><br><span class="line">    &#123;</span><br><span class="line">        iTween.MoveTo(npcMysticMan, new Hashtable</span><br><span class="line">        &#123;</span><br><span class="line">            &#123; &quot;x&quot;, -4.71f &#125;,</span><br><span class="line">            &#123; &quot;isLocal&quot;, true &#125;,</span><br><span class="line">            &#123; &quot;easeType&quot;, iTween.EaseType.linear &#125;,</span><br><span class="line">            &#123; &quot;onComplete&quot;, &quot;MysticManLeave&quot; &#125;,</span><br><span class="line">            &#123; &quot;onCompleteTarget&quot;, gameObject &#125;,</span><br><span class="line">            &#123; &quot;time&quot;, 2f &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="触发第二段对话"><a href="#触发第二段对话" class="headerlink" title="触发第二段对话"></a>触发第二段对话</h3><p>这里与上面的移动事件同理，在神秘人移动结束后调用 <code>MysticManLeave</code> 方法来执行第二段对话。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void MysticManLeave()</span><br><span class="line">&#123;</span><br><span class="line">    MapManager.ChangeDirect(npcMysticMan, Direct.RIGHT);</span><br><span class="line">    MapManager.ChangeDirect(npcBaGu, Direct.LEFT);</span><br><span class="line">    WindowManager.CallDialog(&quot;06_bagu_room&#x2F;03_sitdown&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完成后的代码"><a href="#完成后的代码" class="headerlink" title="完成后的代码"></a>完成后的代码</h3><p>至此，上面的小剧情事件已经用代码实现了。<br>回过来看看全部的代码是怎样的？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private void Event_001()</span><br><span class="line">&#123;</span><br><span class="line">     MapManager.SetTargetLocalPosition(npcMysticMan, 7.08f, -0.62f, Direct.LEFT);</span><br><span class="line"></span><br><span class="line">    iTween.MoveTo(npcMysticMan, new Hashtable</span><br><span class="line">    &#123;</span><br><span class="line">        &#123; &quot;x&quot;, 1.37f &#125;,</span><br><span class="line">        &#123; &quot;isLocal&quot;, true &#125;,</span><br><span class="line">        &#123; &quot;easeType&quot;, iTween.EaseType.linear &#125;,</span><br><span class="line">        &#123; &quot;onComplete&quot;, &quot;Trade&quot; &#125;,</span><br><span class="line">        &#123; &quot;onCompleteTarget&quot;, gameObject &#125;,</span><br><span class="line">        &#123; &quot;time&quot;, 2f &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void Trade()</span><br><span class="line">&#123;</span><br><span class="line">    WindowManager.CallDialog(&quot;06_bagu_room&#x2F;02_trade&quot;, delegate</span><br><span class="line">    &#123;</span><br><span class="line">        iTween.MoveTo(npcMysticMan, new Hashtable</span><br><span class="line">        &#123;</span><br><span class="line">            &#123; &quot;x&quot;, -4.71f &#125;,</span><br><span class="line">            &#123; &quot;isLocal&quot;, true &#125;,</span><br><span class="line">            &#123; &quot;easeType&quot;, iTween.EaseType.linear &#125;,</span><br><span class="line">            &#123; &quot;onComplete&quot;, &quot;MysticManLeave&quot; &#125;,</span><br><span class="line">            &#123; &quot;onCompleteTarget&quot;, gameObject &#125;,</span><br><span class="line">            &#123; &quot;time&quot;, 2f &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void MysticManLeave()</span><br><span class="line">&#123;</span><br><span class="line">    MapManager.ChangeDirect(npcMysticMan, Direct.RIGHT);</span><br><span class="line">    MapManager.ChangeDirect(npcBaGu, Direct.LEFT);</span><br><span class="line">    WindowManager.CallDialog(&quot;06_bagu_room&#x2F;03_sitdown&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来每个事件分明，一个方法控制一个动作，好像没有什么大问题。<br>但是，从逻辑上来讲，这几个方法的关系不是很明确，只是一直在用回调函数调用下一个事件而已。</p>
<p>很明显这种方法的弊端很大，不仅没有明确的关联关系，而且存在重复的代码，如控制神秘人移动事件。<br>这种即属于“面向过程”的编程方法，后期维护很不方便，写起来也很烦躁。<br>上面还只是不到 1 分钟的剧情，如果是更长的剧情，代码随随便便就要写上几千行。</p>
<p>这不仅是代码美不美观的问题，而且还严重影响效率，编写冗余的代码对程序员的身心也不友好。<br>为了保证后续的剧情事件能够「优雅」的开发，需要重制原来的剧情处理事件。</p>
<h2 id="数据结构与设计模式"><a href="#数据结构与设计模式" class="headerlink" title="数据结构与设计模式"></a>数据结构与设计模式</h2><p>这两个名词是大学的时候最害怕的……<br>数据结构就是定义数据是如何进行排列的，比如最简单的就是数组。</p>
<p>数据保存在内存，内存是由一大块很大的空间构成。<br>于是数据就要保存在空间的其中一处，也就是地址。<br>根据一组数据在地址中存在的位置，分成数组和链表两种数据结构。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>1、2、3、4、5，这样按顺序排列，在内存中占用一段连续的地址。</p>
<p><img src="https://files.catbox.moe/xp9tss.png" alt="数组在内存中的结构"></p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表就是一个结构体，也可以是一个类，一共有两个字段，一个是数据，一个是保存下一个数据的地址。<br>用结构体或者类都可以作为链表的数据结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public struct Data &#123;</span><br><span class="line">    int value;</span><br><span class="line">    Data* next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大概就是上面这种结构，<code>Data*</code> 是指向 <code>Data</code> 数据地址的指针。</p>
<blockquote>
<p>注意：某启蒙 C 语言书本上写的“指针就是地址，地址就是指针”，个人以为这种说法不准确，因为这两个是不同的概念，打个比方，你给了我一张纸条，上面写着你家地址，我通过纸条就可以找到你家的位置，那么在这里——纸条就是指针，你家的地址就是地址，可以说这张纸条就是你家吗？很明显不能。指针是一种数据类型，它保存的是某种数据在内存中的地址，通过指针可以找到对应数据的地址。</p>
</blockquote>
<p>链表数据的其中一个字段保存下一个数据的地址，如下。</p>
<p><img src="https://files.catbox.moe/mwunmc.png" alt="链表结构"></p>
<h3 id="数据结构有什么用？"><a href="#数据结构有什么用？" class="headerlink" title="数据结构有什么用？"></a>数据结构有什么用？</h3><p>其实这就是学习的最大敌人——不知道学了有什么用。<br>大学的时候，老师也从来不会告诉你学了知识能用在哪些地方。<br>对着这些枯燥无味的知识，而且还不知道以后能不能用的上，自然就没兴趣学下去了。</p>
<p>但是在经历了几年的开发经验之后，发现这些数据结构在进行系统设计和框架设计非常有用。<br>（当然，如果一直在从事普通的开发岗，基本没机会接触到这些，业务全部都是用别人写好现成的，自然也就学而无用了。）</p>
<p>看下面一组例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string a &#x3D; &quot;aaa&quot;;</span><br><span class="line">string b &#x3D; &quot;bbb&quot;;</span><br></pre></td></tr></table></figure>

<p>这是两个变量，不能叫做数据结构。<br>如果把它们放到一个数组里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string items &#x3D; new string &#123; &quot;aaa&quot;, &quot;bbb&quot; &#125;;</span><br><span class="line"></span><br><span class="line">Debug.Log(items[0]);</span><br><span class="line">Debug.Log(items[1]);</span><br></pre></td></tr></table></figure>

<p>这样就是一个数据结构，因为他们是在一起的变量。<br>也就是说，单个的变量不能叫做数据结构，而需要一个特殊的关系把它们连接在一起才能叫做数据结构。</p>
<p>数组可以通过索引快速找到指定元素，如果知道数组的下标，查找数据的复杂程度是 O(1)，也就是瞬间就找到的意思。<br>链表没有下标的概念，查找数据只能一个个对比，找到对应的值才能返回结果，复杂度是 O(n)，也就是最坏的情况下，有多少个数据就要对比多少次。</p>
<blockquote>
<p>如果不知道下标，只知道值，即使是数组也只能遍历对比数据，复杂度也是 O(n)。</p>
</blockquote>
<p>单个的变量用途十分单一，但是把它们连接在一起功能就变得十分强大了。<br>不仅可以用来搜索数据，还可以定义某些具有特殊功能的结构。</p>
<h3 id="队列和栈"><a href="#队列和栈" class="headerlink" title="队列和栈"></a>队列和栈</h3><p>队列和栈是比较常见的数据结构，其原理就是利用数组或者链表实现。<br>队列是“先进先出”的一种结构，而栈却相反，即“先进反而后出”。</p>
<p>关于栈的用处，之前在设计《名为怪物的游戏》中菜单系统就有介绍。<br>队列和栈如何实现就不科普了，感兴趣的可以自行搜索。</p>
<p>总之，所有的数据结构基本都可以由数组和链表来实现。<br>除了队列和栈，还有堆（树形结构），树型结构又分成很多种，比如二叉树、B 树、B+ 树等等（咱也没深入了解，有兴趣可以自己查）。</p>
<p>MySQL 的索引就是利用树的结构实现的。</p>
<blockquote>
<p>如果当初老师能把数据结构实际的用途告诉我们，那我们应该会比较有兴趣学下去。</p>
</blockquote>
<h3 id="设计模式是什么？"><a href="#设计模式是什么？" class="headerlink" title="设计模式是什么？"></a>设计模式是什么？</h3><p>普通的程序员在上班过程中几乎接触不到设计模式，因为都是用别人设计好的。</p>
<blockquote>
<p>顶多也就是接触到单例模式、工厂模式那些。</p>
</blockquote>
<p>只有在设计框架和系统结构的时候，设计模式才能大显身手。<br>这里暂时用不到，在游戏的开发中设计模式也是很重要的。</p>
<h2 id="剧情事件优化"><a href="#剧情事件优化" class="headerlink" title="剧情事件优化"></a>剧情事件优化</h2><p>上面讲了那么多，全部都是为了优化剧情事件做的铺垫。<br>回到开头剧情的场景：</p>
<ul>
<li>神秘人走过来</li>
<li>开始第一段对话</li>
<li>神秘人走到旁边的椅子</li>
<li>开始第二段对话</li>
</ul>
<p>一段剧情可以分成多个部分，每一个部分就可以看做一个零散的“变量”，把它们组合在一起就是一个数据结构。</p>
<p>剧情的事件执行顺序是一个一个来的，比如先执行神秘人走过来的事件，然后开始第一段对话……以此类推。<br>换句话说，当第一个事件还没执行完成，后面的事件都得“等着”，直到第一个事件完事了，才能轮到下一个事件执行。</p>
<p>上面的场景描述……已经在指名道姓了，说的就是你——队列。<br>先加入的事件，最先处理，也就是在说队列的特点。</p>
<p><code>c#</code> 自带队列数据类型 <code>Queue</code>，不用自己实现。<br><code>Enqueue</code> 方法将一个数据插入队列的尾部，<code>Dequeue</code> 方法从队列头部取出一个数据并将其从队列删除。</p>
<p>利用上述两个方法即可轻松添加和取数据。</p>
<h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p>当一个类的返回值为对象时，就可以实现链式调用。<br>最常见的方法就是一个类返回自身，就可以无限调用自己内部的方法了。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Link &#123;</span><br><span class="line"></span><br><span class="line">    public Link sayHello() &#123;</span><br><span class="line">        Debug.Log(&quot;hello&quot;);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Link link &#x3D; new Link();</span><br><span class="line">link.sayHello().sayHello().sayHello();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码可以无限调用 <code>sayHello</code> 方法，因为调用完这个方法返回了类自身。<br>链式调用属于比较美观的写法，对于代码整洁有很大的帮助。</p>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>首先需要定义一个用来处理剧情流程的事件系统，其实就是一个简单的结构。</p>
<p>第一个类是事件容器，用来保存和处理容器内事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace FR_Event</span><br><span class="line">&#123;</span><br><span class="line">    public class EventContainer</span><br><span class="line">    &#123;</span><br><span class="line">        public Queue&lt;EventActionAbstract&gt; queue &#x3D; new Queue&lt;EventActionAbstract&gt;();</span><br><span class="line"></span><br><span class="line">        public EventContainer Append(EventActionAbstract eventAction)</span><br><span class="line">        &#123;</span><br><span class="line">            queue.Enqueue(eventAction);</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void StartEvent()</span><br><span class="line">        &#123;</span><br><span class="line">            if (queue.Count &#x3D;&#x3D; 0) return;</span><br><span class="line"></span><br><span class="line">            var current &#x3D; queue.Dequeue();</span><br><span class="line">            current.Handle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里为了规范，给类加上了命名空间 <code>namespace FR_Event</code>。<br>命名空间是为了避免重名类的冲突，因为 Unity 在启动时就会加载所有类文件。<br>如果有同名的类就会报错，所以给它加上一个命名空间 <code>FR_Event</code>。<br>这样就可以用 <code>FR_Event.EventContainer</code> 与其他类区分开来。</p>
<p>面向对象有个“开放-封闭”原作，即隐藏无关的内容。<br>在这里，要调用事件，可以增加一个 <code>Manager</code> 类来间接调用事件容器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line"></span><br><span class="line">namespace FR_Event</span><br><span class="line">&#123;</span><br><span class="line">    public class EventManager : MonoBehaviour</span><br><span class="line">    &#123;</span><br><span class="line">        public static EventContainer eventContainer;</span><br><span class="line"></span><br><span class="line">        public static EventContainer StartNewQueue()</span><br><span class="line">        &#123;</span><br><span class="line">            eventContainer &#x3D; new EventContainer();</span><br><span class="line">            return eventContainer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就不用每次都 <code>new</code> 一个 <code>EventContainer</code>。</p>
<p>容器内接收 <code>EventActionAbstract</code> 类型的「事件动作」。<br>每个事件都要继承这个抽象类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">namespace FR_Event</span><br><span class="line">&#123;</span><br><span class="line">    public abstract class EventActionAbstract</span><br><span class="line">    &#123;</span><br><span class="line">        protected void EventEnd()</span><br><span class="line">        &#123;</span><br><span class="line">            FR_Event.EventManager.eventContainer.StartEvent();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public abstract void Handle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类只要有一个 <code>Handle</code>（处理动作的方法），以及一个 <code>EventEnd</code> 事件结束方法。<br><code>Handle</code> 方法要在子类进行重写，因为每个事件都不一样。</p>
<p>接着创建一个对话事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">namespace FR_Event</span><br><span class="line">&#123;</span><br><span class="line">    namespace EventAction</span><br><span class="line">    &#123;</span><br><span class="line">        public class DialogAction : EventActionAbstract</span><br><span class="line">        &#123;</span><br><span class="line">            private string textPath;</span><br><span class="line"></span><br><span class="line">            public DialogAction(string textPath)</span><br><span class="line">            &#123;</span><br><span class="line">                this.textPath &#x3D; textPath;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public override void Handle()</span><br><span class="line">            &#123;</span><br><span class="line">                WindowManager.CallDialog(textPath, EventEnd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里又添加了一层命名空间 <code>EventAction</code>，比较规范的是每一层文件夹就创建一个。</p>
<p><img src="https://files.catbox.moe/bm3a6u.jpg" alt="文件结构"></p>
<p>接着创建两个测试对话文本：</p>
<p><img src="https://files.catbox.moe/wfy3jw.jpg" alt="测试文本"></p>
<p>然后开始“优雅”的实现剧情对话：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FR_Event.EventManager</span><br><span class="line">          .StartNewQueue()</span><br><span class="line">          .Append(new FR_Event.EventAction.DialogAction(&quot;00_test&#x2F;01_text&quot;))</span><br><span class="line">          .Append(new FR_Event.EventAction.DialogAction(&quot;00_test&#x2F;02_text&quot;))</span><br><span class="line">          .StartEvent();</span><br></pre></td></tr></table></figure>

<p>看起来好多了！进游戏测试一下。</p>
<p><img src="https://files.catbox.moe/jc0hvw.gif" alt="对话测试"></p>
<p>接下来只要再编写等待事件、移动事件、增减道具事件、淡入淡出事件……</p>
<p>这样完全可以用链式调用实现整个剧情事件！</p>
<p>参考的完整版代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FR_Event.EventManager</span><br><span class="line">         .StartNewQueue()</span><br><span class="line">         .Append(new FR_Event.EventAction.MoveAction(target, new Vector3(1f, 1f), 1f) &#x2F;&#x2F; 在1秒的时间移动到(1,1)位置</span><br><span class="line">         .Append(new FR_Event.EventAction.WaitAction(1f)) &#x2F;&#x2F; 等待1秒</span><br><span class="line">         .Append(new FR_Event.EventAction.DialogAction(&quot;00_test&#x2F;02_text&quot;)) &#x2F;&#x2F; 执行对话</span><br><span class="line">         .Append(new FR_Event.EventAction.FadeOutAction(2f)) &#x2F;&#x2F; 在2秒内淡出屏幕</span><br><span class="line">         .Append(new FR_Event.EventAction.GoMapAction(&quot;map_name&quot;)) &#x2F;&#x2F; 移动到某个地图</span><br><span class="line">         .StartEvent();</span><br></pre></td></tr></table></figure>

<p>只要编写好以下事件动作：</p>
<ul>
<li>MoveAction：移动事件</li>
<li>WaitAction：等待事件</li>
<li>DialogAction：对话事件</li>
<li>FadeOutAction：淡出事件</li>
<li>GoMapAction：场景移动事件</li>
<li>……更多事件动作</li>
</ul>
<p>无论想要实现什么事件，只要继承 <code>EventActionAbstract</code> 将其用 <code>Append</code> 方法加入到事件容器中就可以优雅的执行了！</p>
<p>最后，如果觉得命名空间有点碍事，可以在顶部用 <code>using</code> 关键词引入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using FR_Event.EventAction;</span><br><span class="line"></span><br><span class="line">FR_Event.EventManager</span><br><span class="line">          .StartNewQueue()</span><br><span class="line">          .Append(new DialogAction(&quot;00_test&#x2F;01_text&quot;))</span><br><span class="line">          .Append(new DialogAction(&quot;00_test&#x2F;02_text&quot;))</span><br><span class="line">          .StartEvent();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如此一来，代码就更加简洁了！</p>
<blockquote>
<p>有了这个剧情事件处理系统，终于解放双手了！</p>
</blockquote>
<p>接下来就可以开开心心的写代码了 ♪(^∇^*)<br>跟乱糟糟的代码 say bye bye ~</p>
<h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>关于游戏剧情的编辑还有很多种方法，上面还是脱离不了代码层面。</p>
<p>也有大佬用 Unity 设计了一套剧情编辑器：</p>
<p><img src="https://files.catbox.moe/t9znpv.jpg" alt="剧情编辑器"></p>
<p>还有这种：</p>
<p><img src="https://files.catbox.moe/c8yrrs.jpg" alt="剧情编辑器2"></p>
<p>看起来密密麻麻，密集恐惧症可能都犯了。<br>对于这种用非代码实现的方式，其实才是最好的方法。<br>因为人为手写代码很容易出错，但如果设计好程序，用程序自动生成就可以避免人为写出的 BUG 了。</p>
<p>除此之外，用文本来写特殊指令的方法也是可以的，总的来说就是把数据转化为指令，可视化的界面目前对我来说难度太高了，我们游戏的体量也没必要专门设计一个制作剧情的工具。</p>
<p>一个程序员写太多代码不是什么值得夸耀的事，反而是能不写代码就实现功能才顶呱噶。</p>
<blockquote>
<p>程序员的最高境界就是“无码”</p>
</blockquote>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">火烧兔子</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://huotuyouxi.com/2021/08/06/game-maker-001/">http://huotuyouxi.com/2021/08/06/game-maker-001/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://huotuyouxi.com">火兔游戏工作室</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/">开发技术</a><a class="post-meta__tags" href="/tags/unity/">unity</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/08/07/future-001/"><i class="fa fa-chevron-left">  </i><span>关于未来的开发计划</span></a></div><div class="next-post pull-right"><a href="/2021/08/01/monster-game-version-102/"><span>《名为怪物的游戏》v1.0.2版本发布</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2021/05/02/61DLs9VHetxbq2n.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2023 By 火烧兔子</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>