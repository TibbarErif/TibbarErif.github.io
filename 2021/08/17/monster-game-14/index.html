<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="《名为怪物的游戏》框架开发篇（优雅的实现菜单系统）"><meta name="keywords" content="开发技术,unity"><meta name="author" content="火烧兔子"><meta name="copyright" content="火烧兔子"><title>《名为怪物的游戏》框架开发篇（优雅的实现菜单系统） | 火兔游戏工作室</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-6777753891073316',
  enable_page_level_ads: 'true'
});
</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8F%9C%E5%8D%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.</span> <span class="toc-text">菜单示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UI-%E6%A8%A1%E5%9E%8B%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="toc-number">3.</span> <span class="toc-text">UI 模型基本思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.2.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%9D%83"><span class="toc-number">3.3.</span> <span class="toc-text">控制权</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UIModel"><span class="toc-number">4.</span> <span class="toc-text">UIModel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UIStack"><span class="toc-number">5.</span> <span class="toc-text">UIStack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E4%B8%AD%E4%BD%BF%E7%94%A8"><span class="toc-number">6.</span> <span class="toc-text">游戏中使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8F%9C%E5%8D%95-UI"><span class="toc-number">6.1.</span> <span class="toc-text">菜单 UI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8F%9C%E5%8D%95%E9%80%BB%E8%BE%91"><span class="toc-number">6.2.</span> <span class="toc-text">菜单逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E8%8F%9C%E5%8D%95"><span class="toc-number">6.2.1.</span> <span class="toc-text">水平菜单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%BC%E5%AD%90%E8%8F%9C%E5%8D%95"><span class="toc-number">6.2.2.</span> <span class="toc-text">格子菜单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%96%E7%9B%B4%E8%8F%9C%E5%8D%95"><span class="toc-number">6.2.3.</span> <span class="toc-text">竖直菜单</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.</span> <span class="toc-text">具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8F%9C%E5%8D%95%E5%9F%BA%E7%B1%BB"><span class="toc-number">7.1.</span> <span class="toc-text">菜单基类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%8F%9C%E5%8D%95"><span class="toc-number">7.2.</span> <span class="toc-text">不同菜单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E8%8F%9C%E5%8D%95"><span class="toc-number">7.3.</span> <span class="toc-text">测试菜单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E9%A1%B9%E5%9F%BA%E7%B1%BB"><span class="toc-number">7.4.</span> <span class="toc-text">选项基类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8F%9C%E5%8D%95%E9%80%89%E9%A1%B9"><span class="toc-number">7.5.</span> <span class="toc-text">菜单选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E8%8F%9C%E5%8D%95"><span class="toc-number">7.6.</span> <span class="toc-text">调用菜单</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">8.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://i.loli.net/2021/05/02/JjR7MmfePax3oc2.jpg"></div><div class="author-info__name text-center">火烧兔子</div><div class="author-info__description text-center">我的世界，在你手中。</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">158</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">44</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">30</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2021/05/02/61DLs9VHetxbq2n.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">火兔游戏工作室</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/archives">归档</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">《名为怪物的游戏》框架开发篇（优雅的实现菜单系统）</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-17</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%96%B0%E6%B8%B8%E5%BC%80%E5%8F%91/">新游开发</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%96%B0%E6%B8%B8%E5%BC%80%E5%8F%91/%E5%90%8D%E4%B8%BA%E6%80%AA%E7%89%A9%E7%9A%84%E6%B8%B8%E6%88%8F/">名为怪物的游戏</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>新素材制作期间，我打算利用这段空闲的时间重构之前写的一些不好的地方。</p>
<p>游戏开发中 UI 的处理是比较复杂的部分。UI 包括窗口、状态栏等等，其中大部分都是展示作用，没有需要控制的地方。本篇文章介绍了一种通过生命周期来实现需要控制的 UI，如菜单系统，优雅的实现方法。</p>
<h2 id="菜单示例"><a href="#菜单示例" class="headerlink" title="菜单示例"></a>菜单示例</h2><p>之前实现的主菜单/存档界面。</p>
<p><img src="https://pic.imgdb.cn/item/60e7f75e5132923bf8060305.gif" alt="主菜单/存档界面"></p>
<p>具体的实现可以前往之前的日志：<a href="https://huotuyouxi.com/2021/07/01/monster-game-version-100-1/#7%E6%9C%889%E6%97%A5">菜单的控制权问题</a></p>
<p>菜单系统的难点在于操作控制权的变换。<br>比如先打开主菜单，然后选择存档，此时主菜单应该被“暂停”不能操控。<br>而关闭存档时，操作权才会返回主菜单。</p>
<p>这个原理是通过栈实现的，不再赘述。</p>
<p>原来的系统虽然已经没问题了，但是代码写的有点散乱。<br>在经过了一番学习之后，有了更加系统化的思路，所以我决定来优化一下菜单系统。</p>
<h2 id="UI-模型基本思路"><a href="#UI-模型基本思路" class="headerlink" title="UI 模型基本思路"></a>UI 模型基本思路</h2><p>菜单系统的权限控制非常繁琐，如果是面向过程的开发，简直要崩溃……<br>现在要做的事就是开发一个 UI 框架来自动处理这些麻烦的事情，解放自己的双手。</p>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>UI 框架一共包括两个类：</p>
<ul>
<li>UIModel</li>
<li>UIStack</li>
</ul>
<p><code>UIModel</code> 是菜单系统的父类，该类包含了 UI 从创建到销毁的处理。<br><code>UIStack</code> 是菜单的管理类，用来控制菜单的权限自动化处理。</p>
<p>为了统一规范，所有的 UI 都应当用 <code>Image</code> 来实现，而不是 <code>SpriteRender</code>。<br>在 Unity 中，UI 类型的组件必须挂在 <code>Canvas</code>（画板）底下。<br>因此，在场景中创建一个画板，然后把 <code>UIStack</code> 脚本挂在画板里，实现 UI 的全局管理。</p>
<p><img src="https://pic.imgdb.cn/item/611b8c174907e2d39c14539f.jpg" alt="UICanvas"></p>
<p>主场景中的结构如上图所示。<br>接着在主场景的脚本中添加一个获取 <code>UIStack</code> 的变量，并且将 <code>UICanvas</code> 拖进去：</p>
<p><img src="https://pic.imgdb.cn/item/611b8c5c4907e2d39c1501b3.jpg" alt="UIStack"></p>
<p>这样主场景就可以对 UI 进行管理了。</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>不管是什么框架都有着『生命周期』的概念。<br>即创建时、创建后、销毁时……诸如此类。</p>
<p>生命周期指的是一个系统从创建开始，直到运行结束销毁回收的过程。<br>为了让代码的条理更加清晰，新的系统也引入生命周期的概念。</p>
<blockquote>
<p>Unity 中的 Awake、Start、OnDestroy 就是生命周期函数</p>
</blockquote>
<p>通过生命周期来管理一个菜单 <code>UIModel</code> 的创建以及销毁的过程。</p>
<h3 id="控制权"><a href="#控制权" class="headerlink" title="控制权"></a>控制权</h3><p>菜单的基本实现就是利用了栈的特性，在入栈时将上级菜单暂停，在出栈时才解除暂停状态。<br>栈的结构可以用链表来轻松实现，<code>C#</code> 中就有链表类型 <code>LinkedList</code>。</p>
<blockquote>
<p>这个类型也是我刚刚发现的……</p>
</blockquote>
<p>链表主要提供两个方法：<code>Pop</code> 和 <code>Push</code>。</p>
<p><code>Pop</code> 方法从尾部取一个元素，并将其从链表中删除。<br><code>Push</code> 方法将一个元素添加到链表的尾部。</p>
<p>在这两个操作的过程中即可对菜单的权限进行处理。<br>在新菜单入栈时，将上级菜单暂停；当菜单关闭时，将上级菜单解除暂停。</p>
<h2 id="UIModel"><a href="#UIModel" class="headerlink" title="UIModel"></a>UIModel</h2><p><code>UIModel</code> 是菜单系统的父类，包含了对生命周期的处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace FR</span><br><span class="line">&#123;</span><br><span class="line">    public abstract class UIModel : MonoBehaviour</span><br><span class="line">    &#123;</span><br><span class="line">        protected UIStack stack;</span><br><span class="line"></span><br><span class="line">        private void Awake()</span><br><span class="line">        &#123;</span><br><span class="line">            OnCreate();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void Start()</span><br><span class="line">        &#123;</span><br><span class="line">            OnLoad();</span><br><span class="line">            OnLoadAction();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void OnDestroy()</span><br><span class="line">        &#123;</span><br><span class="line">            OnRelease();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void Update()</span><br><span class="line">        &#123;</span><br><span class="line">            OnUpdate();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void FixedUpdate()</span><br><span class="line">        &#123;</span><br><span class="line">            OnFixedUpdate();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void BindStack(UIStack stack)</span><br><span class="line">        &#123;</span><br><span class="line">            this.stack &#x3D; stack;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected abstract void OnLoadAction();</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 让UI处于暂停状态，不可进行操作</span><br><span class="line">         *&#x2F;</span><br><span class="line">        public abstract void Pause();</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 从暂停状态恢复</span><br><span class="line">         *&#x2F;</span><br><span class="line">        public abstract void Resume();</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 关闭UI是一件复杂的行为</span><br><span class="line">         * 此处暴露一个简单的方法以便外部直接调用</span><br><span class="line">         *&#x2F;</span><br><span class="line">        public void Close()</span><br><span class="line">        &#123;</span><br><span class="line">            if (stack &#x3D;&#x3D; null) return;</span><br><span class="line"></span><br><span class="line">            stack.Pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 仅提供给UIStack调用</span><br><span class="line">         * 执行关闭动画，返回动画的时间</span><br><span class="line">         * 当动画播放结束后，会被stack回收</span><br><span class="line">         * 这里只需要执行关闭窗口的效果，而不需要执行Destroy，销毁由stack执行</span><br><span class="line">         *&#x2F;</span><br><span class="line">        public abstract float OnCloseAction();</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 生命周期</span><br><span class="line">         *&#x2F;</span><br><span class="line">        protected virtual void OnCreate() &#123; &#125;</span><br><span class="line">        protected virtual void OnLoad() &#123; &#125;</span><br><span class="line">        protected virtual void OnUpdate() &#123; &#125;</span><br><span class="line">        protected virtual void OnFixedUpdate() &#123; &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 在被Destroy之前再调用一次OnCloseBefore</span><br><span class="line">         * 然后就会被Destroy销毁</span><br><span class="line">         *&#x2F;</span><br><span class="line">        public virtual void OnCloseBefore() &#123; &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 执行了Destroy之后最后调用一次OnRelease</span><br><span class="line">         * 整个生命周期就结束了</span><br><span class="line">         *&#x2F;</span><br><span class="line">        protected virtual void OnRelease() &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关的说明见注释部分。</p>
<h2 id="UIStack"><a href="#UIStack" class="headerlink" title="UIStack"></a>UIStack</h2><p><code>UIStack</code> 以栈结构保存所有的菜单，并且在出入栈时对权限进行管理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace FR</span><br><span class="line">&#123;</span><br><span class="line">    [RequireComponent(typeof(Canvas))]</span><br><span class="line">    public class UIStack : MonoBehaviour</span><br><span class="line">    &#123;</span><br><span class="line">        private RectTransform rectTransform;</span><br><span class="line">        private LinkedList&lt;UIModel&gt; uiModels &#x3D; new LinkedList&lt;UIModel&gt;();</span><br><span class="line"></span><br><span class="line">        private void Awake()</span><br><span class="line">        &#123;</span><br><span class="line">            rectTransform &#x3D; GetComponent&lt;RectTransform&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public UIModel Push(GameObject prefab)</span><br><span class="line">        &#123;</span><br><span class="line">            if (!prefab)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogError(&quot;prefab为空&quot;);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var component &#x3D; prefab.GetComponent&lt;UIModel&gt;();</span><br><span class="line"></span><br><span class="line">            if (!component)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogError(&quot;没有UIModel组件&quot;);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果在链表中存在其他的UI，则把最后的一个UI设置为暂停状态</span><br><span class="line">            var last &#x3D; (uiModels.Last !&#x3D; null) ? uiModels.Last.Value : null;</span><br><span class="line">            if (last)</span><br><span class="line">            &#123;</span><br><span class="line">                last.Pause();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 调用Unity的Instantiate方法实例化UI对象</span><br><span class="line">            var obj &#x3D; ObjectBuilder.Generate(prefab, rectTransform);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 将当前类绑定到UI类中，以便其内部调用</span><br><span class="line">            var model &#x3D; obj.GetComponent&lt;UIModel&gt;();</span><br><span class="line">            model.BindStack(this);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 将新加入的UI类添加到链表的尾部</span><br><span class="line">            uiModels.AddLast(model);</span><br><span class="line"></span><br><span class="line">            return model;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void Pop()</span><br><span class="line">        &#123;</span><br><span class="line">            if (uiModels.Last &#x3D;&#x3D; null) return;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 取出最后一个UI类并将其移出链表</span><br><span class="line">            var model &#x3D; uiModels.Last.Value;</span><br><span class="line">            uiModels.RemoveLast();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 移除绑定</span><br><span class="line">            model.BindStack(null);</span><br><span class="line"></span><br><span class="line">            &#x2F;**</span><br><span class="line">             * 执行窗口的关闭动画，并且获得动画关闭的等待时间</span><br><span class="line">             * 其实这一步是并行执行的，动画仍在播放，但是先返回一个等待时间给UIStack调用</span><br><span class="line">             * 直接返回动画的时间目的在于解耦</span><br><span class="line">             * 并行处理的好处是降低代码的耦合，但坏处是关闭动画的时间太长时会明显感觉不协调</span><br><span class="line">             * 即在关闭当前UI后，此时UI仍在播放关闭动画，可是上级UI却可以在播放动画期间进行操作</span><br><span class="line">             * 因此在获得动画播放时间的时，进入协程等待状态（与动画播放时间相同）</span><br><span class="line">             * 以此保证关闭动画结束时正好解除上级UI的暂停状态</span><br><span class="line">             *&#x2F;</span><br><span class="line">            float time &#x3D; model.OnCloseAction();</span><br><span class="line"></span><br><span class="line">            StartCoroutine(WaitCloseActionCompleted(model, time));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private IEnumerator WaitCloseActionCompleted(UIModel model, float time)</span><br><span class="line">        &#123;</span><br><span class="line">            yield return new WaitForSeconds(time);</span><br><span class="line"></span><br><span class="line">            var last &#x3D; (uiModels.Last !&#x3D; null) ? uiModels.Last.Value : null;</span><br><span class="line">            if (last)</span><br><span class="line">            &#123;</span><br><span class="line">                last.Resume();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            model.OnCloseBefore();</span><br><span class="line"></span><br><span class="line">            Destroy(model.gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该类需要挂在场景的 <code>Canvas</code> 节点里。<br><code>Push</code> 方法通过传入 <code>Prefab</code>（预制体）参数来实例化菜单节点。<br>同时将新增的菜单的脚本加入到栈里面，并且对上级菜单进行了暂停操作。</p>
<p><code>Pop</code> 方法是将最后一个打开的菜单进行销毁，同时解除上级菜单的暂停状态。<br>此处添加一个协程用来处理关闭动画，也可以不加这个方法而是直接销毁菜单。</p>
<h2 id="游戏中使用"><a href="#游戏中使用" class="headerlink" title="游戏中使用"></a>游戏中使用</h2><p>这两个类属于框架类，不包含任何游戏相关的逻辑，比如菜单的按键控制等。<br>因此需要在游戏项目中，通过继承 <code>UIModel</code> 的方法来创建一个菜单。</p>
<h3 id="菜单-UI"><a href="#菜单-UI" class="headerlink" title="菜单 UI"></a>菜单 UI</h3><p>在场景中创建一个简单的白底菜单，包括几个选项。</p>
<p><img src="https://pic.imgdb.cn/item/611b96174907e2d39c2bc70e.jpg" alt="菜单UI"></p>
<p>目前这个菜单只是一张静态的图，没有控制功能。</p>
<h3 id="菜单逻辑"><a href="#菜单逻辑" class="headerlink" title="菜单逻辑"></a>菜单逻辑</h3><p>菜单有水平选项的，也有竖直方向的，还有格子排列的。<br>每一种菜单的控制操作都不同，但是其他的地方却基本相同，因此可以封装一个所有类型菜单的基类。<br>然后不同的菜单只要继承这个类，再去实现对应的控制方法即可。</p>
<h4 id="水平菜单"><a href="#水平菜单" class="headerlink" title="水平菜单"></a>水平菜单</h4><p>水平方向的菜单只能左右移动选项，选项只有一个横排。</p>
<p><img src="https://pic.imgdb.cn/item/611b97624907e2d39c2eaef0.jpg" alt="水平菜单"></p>
<h4 id="格子菜单"><a href="#格子菜单" class="headerlink" title="格子菜单"></a>格子菜单</h4><p>格子菜单可以上下左右按键控制，选项至少有两排。</p>
<p><img src="https://pic.imgdb.cn/item/611b96934907e2d39c2ce048.jpg" alt="格子菜单，选项可以上下左右操作"></p>
<h4 id="竖直菜单"><a href="#竖直菜单" class="headerlink" title="竖直菜单"></a>竖直菜单</h4><p>竖直方向的菜单只能通过上下键移动选项，选项只有一个竖列。</p>
<p><img src="https://pic.imgdb.cn/item/611b96e04907e2d39c2d8bdb.jpg" alt="竖直菜单"></p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>接下来演示如何实现一个竖直方向的菜单系统，其他类型的菜单原理大同小异。</p>
<h3 id="菜单基类"><a href="#菜单基类" class="headerlink" title="菜单基类"></a>菜单基类</h3><p>首选创建所有菜单的基类 <code>MenuBase</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using FR;</span><br><span class="line"></span><br><span class="line">namespace Refactor</span><br><span class="line">&#123;</span><br><span class="line">    public abstract class MenuBase : UIModel</span><br><span class="line">    &#123;</span><br><span class="line">        public Transform itemLayout;</span><br><span class="line">        public List&lt;MenuItemBase&gt; menuItems;</span><br><span class="line">        protected int currentIndex;</span><br><span class="line"></span><br><span class="line">        protected bool isPause, disableCancle, isDestorySelf, isDestoryParent;</span><br><span class="line"></span><br><span class="line">        protected override void OnCreate()</span><br><span class="line">        &#123;</span><br><span class="line">            InitStatusAction();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected override void OnLoadAction()</span><br><span class="line">        &#123;</span><br><span class="line">            SetDefaultStatus();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void SetDefaultStatus()</span><br><span class="line">        &#123;</span><br><span class="line">            menuItems[0].SetActiveStatus();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 设置为禁止取消【X键】关闭菜单</span><br><span class="line">         *&#x2F;</span><br><span class="line">        protected void SetDisabledCancle()</span><br><span class="line">        &#123;</span><br><span class="line">            disableCancle &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 将菜单设置为自销毁类型</span><br><span class="line">         * 即在确定的时候会调用关闭事件</span><br><span class="line">         * 设置为false表示这是个上级菜单，在打开子菜单的时候保留窗口</span><br><span class="line">         * 设置为true时，菜单在完成事件后会执行销毁操作（只是销毁自身不包括上级菜单）</span><br><span class="line">         *&#x2F;</span><br><span class="line">        protected void SetDestroySelfOnCompleted()</span><br><span class="line">        &#123;</span><br><span class="line">            isDestorySelf &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 菜单完成操作时，是否销毁自身及所有上级菜单</span><br><span class="line">         * 即在确定的时候会调用关闭事件</span><br><span class="line">         * 设置为false表示该菜单只关闭自身，上级菜单不受影响</span><br><span class="line">         * 设置为true时，该菜单在完成操作后会连上级菜单也一并销毁</span><br><span class="line">         *&#x2F;</span><br><span class="line">        protected void SetDestroyParentOnCompleted()</span><br><span class="line">        &#123;</span><br><span class="line">            SetDestroySelfOnCompleted();</span><br><span class="line">            isDestoryParent &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public override void Pause()</span><br><span class="line">        &#123;</span><br><span class="line">            isPause &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public override void Resume()</span><br><span class="line">        &#123;</span><br><span class="line">            isPause &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 菜单的初始化操作</span><br><span class="line">         * 需要设置是否销毁自身或者关闭时是否销毁上级菜单等</span><br><span class="line">         *&#x2F;</span><br><span class="line">        protected abstract void InitStatusAction();</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">        * 监听竖直和水平方向按键</span><br><span class="line">        *&#x2F;</span><br><span class="line">        protected virtual void VeticalPrev() &#123; &#125;</span><br><span class="line">        protected virtual void VeticalNext() &#123; &#125;</span><br><span class="line">        protected virtual void HorizontalPrev() &#123; &#125;</span><br><span class="line">        protected virtual void HorizontalNext() &#123; &#125;</span><br><span class="line"></span><br><span class="line">        protected void Handle()</span><br><span class="line">        &#123;</span><br><span class="line">            menuItems[currentIndex].Handle();</span><br><span class="line"></span><br><span class="line">            if (isDestorySelf)</span><br><span class="line">            &#123;</span><br><span class="line">                Close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected override void OnRelease()</span><br><span class="line">        &#123;</span><br><span class="line">            if (isDestoryParent)</span><br><span class="line">            &#123;</span><br><span class="line">                stack.Pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected override void OnUpdate()</span><br><span class="line">        &#123;</span><br><span class="line">            if (isPause) return;</span><br><span class="line"></span><br><span class="line">            if (KeyManager.GetConfirmKeyDown())</span><br><span class="line">            &#123;</span><br><span class="line">                Handle();</span><br><span class="line">            &#125;</span><br><span class="line">            else if (Input.GetKeyDown(KeyCode.X) &amp;&amp; disableCancle &#x3D;&#x3D; false)</span><br><span class="line">            &#123;</span><br><span class="line">                Close();</span><br><span class="line">            &#125;</span><br><span class="line">            else if (Input.GetKeyDown(KeyCode.UpArrow))</span><br><span class="line">            &#123;</span><br><span class="line">                VeticalPrev();</span><br><span class="line">            &#125;</span><br><span class="line">            else if (Input.GetKeyDown(KeyCode.DownArrow))</span><br><span class="line">            &#123;</span><br><span class="line">                VeticalNext();</span><br><span class="line">            &#125;</span><br><span class="line">            else if (Input.GetKeyDown(KeyCode.LeftArrow))</span><br><span class="line">            &#123;</span><br><span class="line">                HorizontalPrev();</span><br><span class="line">            &#125;</span><br><span class="line">            else if (Input.GetKeyDown(KeyCode.RightArrow))</span><br><span class="line">            &#123;</span><br><span class="line">                HorizontalNext();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>菜单基类定义了一个菜单具有的基本功能，其中要注意的是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public override void Pause()</span><br><span class="line">&#123;</span><br><span class="line">    isPause &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public override void Resume()</span><br><span class="line">&#123;</span><br><span class="line">    isPause &#x3D; false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Pause</code> 用来实现暂停菜单操作的功能；<br><code>Resume</code> 用来解除菜单的暂停状态。<br>这里使用一个布尔型的变量 <code>isPause</code> 来控制即可。</p>
<p>一些菜单不希望可以按 <code>X</code> 键取消，比如战斗中的操作选项；<br>一些菜单在按下确定后，只希望关闭当前窗口，而不是连上级菜单也一起关闭；<br>一些菜单在按下确定键后，希望可以关闭所有打开的窗口。<br>这些都需要一个布尔型的变量来控制，菜单的基本配置在 <code>InitStatusAction</code> 进行设置。</p>
<p>除此之外，所有的菜单都有「选项」以及初始化选项的方法，具体的初始化行为在子类的 <code>OnLoadAction</code> 进行实现。</p>
<h3 id="不同菜单"><a href="#不同菜单" class="headerlink" title="不同菜单"></a>不同菜单</h3><p>接着创建三个基本类型的菜单类：</p>
<p><img src="https://pic.imgdb.cn/item/611b99024907e2d39c32926b.jpg" alt="基本类型的菜单类"></p>
<p><code>HorizontalMenu</code> 是水平类型的菜单；<br><code>VerticalMenu</code> 是竖直类型的菜单；<br><code>GridMenu</code> 是格子类型的菜单。</p>
<p>这些基本大同小异，区别在于控制按键的方法，这边只演示竖直类型的菜单类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace Refactor</span><br><span class="line">&#123;</span><br><span class="line">    public abstract class VeritalMenu : MenuBase</span><br><span class="line">    &#123;</span><br><span class="line">        protected override void VeticalNext()</span><br><span class="line">        &#123;</span><br><span class="line">            menuItems[currentIndex].SetUnActiveStatus();</span><br><span class="line">            currentIndex++;</span><br><span class="line"></span><br><span class="line">            if (currentIndex &gt;&#x3D; menuItems.Count)</span><br><span class="line">            &#123;</span><br><span class="line">                currentIndex &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            menuItems[currentIndex].SetActiveStatus();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected override void VeticalPrev()</span><br><span class="line">        &#123;</span><br><span class="line">            menuItems[currentIndex].SetUnActiveStatus();</span><br><span class="line">            currentIndex--;</span><br><span class="line"></span><br><span class="line">            if (currentIndex &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                currentIndex &#x3D; menuItems.Count - 1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            menuItems[currentIndex].SetActiveStatus();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本方法都在 <code>MenuBase</code> 写好了，所以子类只需要实现控制按键的部分即可。</p>
<h3 id="测试菜单"><a href="#测试菜单" class="headerlink" title="测试菜单"></a>测试菜单</h3><p>接下来创建一个用于测试的菜单 <code>TestMenu</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using FR;</span><br><span class="line"></span><br><span class="line">namespace Refactor</span><br><span class="line">&#123;</span><br><span class="line">    public class TestMenu : VeritalMenu</span><br><span class="line">    &#123;</span><br><span class="line">        public override float OnCloseAction()</span><br><span class="line">        &#123;</span><br><span class="line">            return 0f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected override void InitStatusAction()</span><br><span class="line">        &#123;</span><br><span class="line">            SetDestroySelfOnCompleted();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected override void OnLoadAction()</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 5; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                GameObject obj &#x3D; ObjectBuilder.Generate(&quot;Prefabs&#x2F;Test&#x2F;Refactor&#x2F;TestMenuItem&quot;, itemLayout);</span><br><span class="line">                obj.transform.localScale &#x3D; Vector3.one;</span><br><span class="line"></span><br><span class="line">                var item &#x3D; obj.GetComponent&lt;MenuItemBase&gt;();</span><br><span class="line"></span><br><span class="line">                item.BindParent(this);</span><br><span class="line">                menuItems.Add(item);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            SetDefaultStatus();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为没有添加关闭菜单的动画效果，所以 <code>OnCloseAction</code> 直接返回一个零即可。<br><code>InitStatusAction</code> 方法配置菜单的基本参数，将其设置为自销毁类型，即在确定后就关闭。<br><code>OnLoadAction</code> 方法生成菜单的选项，这里直接用了框架里的 <code>ObjectBuilder</code> 来动态创建选项。</p>
<h3 id="选项基类"><a href="#选项基类" class="headerlink" title="选项基类"></a>选项基类</h3><p>接下来创建选项类的脚本，首先创建一个选项的父类 <code>MenuItemBase</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace Refactor</span><br><span class="line">&#123;</span><br><span class="line">    public abstract class MenuItemBase : MonoBehaviour</span><br><span class="line">    &#123;</span><br><span class="line">        protected MenuBase parentMenu;</span><br><span class="line"></span><br><span class="line">        protected virtual void Awake()</span><br><span class="line">        &#123;</span><br><span class="line">            OnCreate();</span><br><span class="line">            SetUnActiveStatus();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void BindParent(MenuBase parentMenu)</span><br><span class="line">        &#123;</span><br><span class="line">            this.parentMenu &#x3D; parentMenu;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public abstract void OnCreate();</span><br><span class="line">        public abstract void SetUnActiveStatus();</span><br><span class="line">        public abstract void SetActiveStatus();</span><br><span class="line">        public abstract void Handle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选项的父类包含了选项激活 <code>SetActiveStatus</code> 方法与 <code>SetUnActiveStatus</code> 未激活。<br>即当光标移动到该选项时，选项的变化效果，演示的菜单选项会在激活时改变背景颜色。</p>
<p><code>BindParent</code> 方法绑定菜单面板类，方便在子类对父类的一些行为进行控制。<br><code>OnCreate</code> 即在菜单选项初始化时的操作，比如将选项的文字进行本地化处理。<br><code>Handle</code> 为菜单选项的实际逻辑，即选中并且按下确认键后要做什么。</p>
<h3 id="菜单选项"><a href="#菜单选项" class="headerlink" title="菜单选项"></a>菜单选项</h3><p>接着创建 <code>TestMenuItem</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.UI;</span><br><span class="line"></span><br><span class="line">namespace Refactor</span><br><span class="line">&#123;</span><br><span class="line">    public class TestMenuItem : MenuItemBase</span><br><span class="line">    &#123;</span><br><span class="line">        private Image bg;</span><br><span class="line"></span><br><span class="line">        public override void Handle()</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(&quot;选中&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public override void OnCreate()</span><br><span class="line">        &#123;</span><br><span class="line">            bg &#x3D; GetComponent&lt;Image&gt;();</span><br><span class="line">            SetUnActiveStatus();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public override void SetActiveStatus()</span><br><span class="line">        &#123;</span><br><span class="line">            bg.color &#x3D; new Color(1f, 0f, 0f);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public override void SetUnActiveStatus()</span><br><span class="line">        &#123;</span><br><span class="line">            bg.color &#x3D; new Color(0.5f, 0.5f, 0.5f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在初始化方法 <code>OnCreate</code> 中，获得 <code>Image</code> 组件，并且在激活与未激活状态时对其进行变色处理。<br><code>Handle</code> 方法打印了一个字符串，当按下确定键后就会打出这个字符串。</p>
<p>以上就完成了一个菜单系统。</p>
<h3 id="调用菜单"><a href="#调用菜单" class="headerlink" title="调用菜单"></a>调用菜单</h3><p>在 <code>MainScene</code> 中调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void CreateMainMenu()</span><br><span class="line">&#123;</span><br><span class="line">    GameObject prefab &#x3D; Resources.Load&lt;GameObject&gt;(&quot;Prefabs&#x2F;Test&#x2F;Refactor&#x2F;TestMenu&quot;);</span><br><span class="line">    var model &#x3D; uiStack.Push(prefab);</span><br><span class="line"></span><br><span class="line">    model.transform.localScale &#x3D; Vector3.one;</span><br><span class="line">    model.transform.localPosition &#x3D; Vector3.zero;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需要载入菜单的预制体，然后将预制体推送到 <code>UIStack</code> 即可创建出菜单了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>新的菜单系统利用生命周期来控制菜单的行为，极大的减少了开发的负担。<br>而且这样一个条理清晰的结构，后期维护起来也简单。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">火烧兔子</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://huotuyouxi.com/2021/08/17/monster-game-14/">http://huotuyouxi.com/2021/08/17/monster-game-14/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://huotuyouxi.com">火兔游戏工作室</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/">开发技术</a><a class="post-meta__tags" href="/tags/unity/">unity</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/08/20/unity-tips-001/"><i class="fa fa-chevron-left">  </i><span>【Unity小技巧】横版平台游戏之单点判定法接触地板检测</span></a></div><div class="next-post pull-right"><a href="/2021/08/13/monster-game-13/"><span>《名为怪物的游戏》框架开发篇（素材的处理）</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2021/05/02/61DLs9VHetxbq2n.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2023 By 火烧兔子</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>