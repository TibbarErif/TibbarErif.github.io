<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="《名为怪物的游戏》框架开发篇（素材的处理）"><meta name="keywords" content="开发技术,unity"><meta name="author" content="火烧兔子"><meta name="copyright" content="火烧兔子"><title>《名为怪物的游戏》框架开发篇（素材的处理） | 火兔游戏工作室</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-6777753891073316',
  enable_page_level_ads: 'true'
});
</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A0%E6%9D%90%E8%AF%B4%E6%98%8E"><span class="toc-number">1.</span> <span class="toc-text">素材说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A0%E6%9D%90%E8%A7%84%E6%A0%BC"><span class="toc-number">2.</span> <span class="toc-text">素材规格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E9%9B%86"><span class="toc-number">3.</span> <span class="toc-text">图集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E9%9B%86%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">3.1.</span> <span class="toc-text">图集的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E9%9B%86%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">3.2.</span> <span class="toc-text">图集的缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E6%A0%87%E5%87%86"><span class="toc-number">4.</span> <span class="toc-text">格式标准</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E9%9B%86%E5%88%87%E5%89%B2"><span class="toc-number">5.</span> <span class="toc-text">图集切割</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E9%9B%86%E6%8F%92%E4%BB%B6"><span class="toc-number">6.</span> <span class="toc-text">图集插件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E8%A7%84%E8%8C%83"><span class="toc-number">7.</span> <span class="toc-text">插件规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E5%88%B6%E4%BD%9C"><span class="toc-number">8.</span> <span class="toc-text">动画制作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E8%A1%8C%E8%B5%B0%E5%9B%BE"><span class="toc-number">8.1.</span> <span class="toc-text">加载行走图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E8%B5%B0%E5%9B%BE%E5%8A%A8%E7%94%BB"><span class="toc-number">8.2.</span> <span class="toc-text">行走图动画</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%92%E8%89%B2%E7%B1%BB%E7%9A%84%E6%96%B0%E8%AE%BE%E8%AE%A1"><span class="toc-number">9.</span> <span class="toc-text">角色类的新设计</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://i.loli.net/2021/05/02/JjR7MmfePax3oc2.jpg"></div><div class="author-info__name text-center">火烧兔子</div><div class="author-info__description text-center">我的世界，在你手中。</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">158</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">44</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">30</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2021/05/02/61DLs9VHetxbq2n.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">火兔游戏工作室</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/archives">归档</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">《名为怪物的游戏》框架开发篇（素材的处理）</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-13</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%96%B0%E6%B8%B8%E5%BC%80%E5%8F%91/">新游开发</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%96%B0%E6%B8%B8%E5%BC%80%E5%8F%91/%E5%90%8D%E4%B8%BA%E6%80%AA%E7%89%A9%E7%9A%84%E6%B8%B8%E6%88%8F/">名为怪物的游戏</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="素材说明"><a href="#素材说明" class="headerlink" title="素材说明"></a>素材说明</h2><p>素材即游戏中需要的图片、音乐等等。<br>图片素材主要是行走图的处理，本作中使用「序列帧」动画制作行走图。</p>
<h2 id="素材规格"><a href="#素材规格" class="headerlink" title="素材规格"></a>素材规格</h2><p>图片在游戏中叫做 Sprite（精灵），一般都是单张图片，也可以是多张图片合成在一起，合成在一起的图片叫做 Sheet（精灵表/图集）。</p>
<p>RPG Maker 行走图教程：<a target="_blank" rel="noopener" href="https://jobyu.gitbooks.io/rpgmakerpixeltutorials/content/di-shi-qi-zhang-ff1a-xing-zou-tu.html">行走图教程</a></p>
<p>RPG Maker 系列的行走图示例：</p>
<p><img src="https://pic.imgdb.cn/item/611339af5132923bf8c860cd.jpg" alt="RPG Maker行走图"></p>
<p>一般都是用专门的打包工具合成这样的图集。<br>图集打包工具：<a target="_blank" rel="noopener" href="https://www.codeandweb.com/texturepacker">TexturePacker 官方网站</a></p>
<h2 id="图集"><a href="#图集" class="headerlink" title="图集"></a>图集</h2><p>通常的游戏开发引擎都可以读取图集。<br>使用打包工具合成一张图集之后还会得到一个文本文件：</p>
<p><img src="https://pic.imgdb.cn/item/61133ad15132923bf8c9ff99.jpg" alt="图集文本"></p>
<p>文本记录了一个 JSON 格式的字符串，用来保存偏移位置等等图片的信息。<br>游戏开发引擎可以读取这个文本从而实现图片的切割。</p>
<h3 id="图集的优点"><a href="#图集的优点" class="headerlink" title="图集的优点"></a>图集的优点</h3><p>游戏引擎有个 <code>DrawCall</code>（绘图次数），Draw Call 就是 CPU 调用图形编程接口，比如 DirectX 或 OpenGL 来命令 GPU 进行渲染的操作。</p>
<p>简单地说这个值越低越好，数值越高表示要画图的次数越多，这样游戏的性能就会下降。<br>使用图集可以降低 <code>DrawCall</code>（具体的原理还未深究）。<br>但是一次性加载一张图片和每次画图都要加载单张图片相比，效率肯定高得多。</p>
<p>除了提高画图的性能，还有一个优点就是方便开发者调用。<br>如果是单张图片开发者不使用脚本读取的话，就要一张张拖到组件里；但如果使用图集打包之后，只要拖一次。如果使用脚本动态读取，图集只要加载一次，而单张图片却要加载 N 次，不管是性能还是操作上，图集都要优于单张图片。</p>
<h3 id="图集的缺点"><a href="#图集的缺点" class="headerlink" title="图集的缺点"></a>图集的缺点</h3><p>因为图片打包在一起，所以修改其中一张就得重新打包。<br>而且如果图集里包含了不需要用到的图片就白白加载了多余的资源。</p>
<h2 id="格式标准"><a href="#格式标准" class="headerlink" title="格式标准"></a>格式标准</h2><p>为了避免改图必须重新全部打包的问题，我们决定图集只包含单个动作。</p>
<p>攻击动作：<br><img src="https://pic.imgdb.cn/item/61133e2e5132923bf8cf7718.jpg" alt="攻击动作"></p>
<p>倒地动作：<br><img src="https://pic.imgdb.cn/item/61133e3e5132923bf8cf935c.jpg" alt="倒地动作"></p>
<p>像这样每一个动作都是一张图集，如果要改动其中一个动作就不必全部重新打包了。</p>
<h2 id="图集切割"><a href="#图集切割" class="headerlink" title="图集切割"></a>图集切割</h2><p>使用 TexturePacker 将行走图打包成单张图片：</p>
<p><img src="https://pic.imgdb.cn/item/611385e95132923bf8561a85.jpg" alt="行走图"></p>
<p>可以使用 Unity 内置的分割程序将图片切分成 4 等分。</p>
<p><img src="https://pic.imgdb.cn/item/611386315132923bf856bcd3.jpg" alt="Unity切分图集"></p>
<h2 id="图集插件"><a href="#图集插件" class="headerlink" title="图集插件"></a>图集插件</h2><p>参考教程：<a target="_blank" rel="noopener" href="https://blog.csdn.net/ChinarCSDN/article/details/85059102">Unity3D-图集制作插件TexturePacker中文教程
</a><br>（作者：Chinarcsdn）</p>
<p>Unity 商店提供了一款可以读取 TexturePacker 切割数据的插件：<a target="_blank" rel="noopener" href="https://assetstore.unity.com/packages/tools/sprite-management/texturepacker-importer-16641">TexturePacker Import</a></p>
<p><img src="https://pic.imgdb.cn/item/6115d6625132923bf84bbfe2.jpg" alt="TexturePacker Import"></p>
<p>从商店把资源添加到账户里，接着导入到游戏项目中：</p>
<p><img src="https://pic.imgdb.cn/item/6115d6bb5132923bf84c5770.jpg" alt="插件包管理"></p>
<p>导入插件的时候，插件内的 Example（范例）是没什么用的，可以不勾上。</p>
<p><img src="https://pic.imgdb.cn/item/6115d7555132923bf84d56fe.jpg" alt="移除不必要的文件"></p>
<p>第一次导入的时候，插件会查找本地的文件，如果有图集就会自动加载，这个过程比较漫长（如果本地图片多的话）。<br>趁这个时间，打开 TexturePacker，然后重新合成一份 unity 支持的图集类型：</p>
<p><img src="https://pic.imgdb.cn/item/6115d8475132923bf84ef0f7.jpg" alt="unity 支持的图集类型"></p>
<p>打包完成后，有一个合并的图像文件和一个 <code>.tpsheet</code> 后缀的文件：</p>
<p><img src="https://pic.imgdb.cn/item/6115d8985132923bf84f7ed4.jpg" alt="tpsheet"></p>
<p>这个文件是图集的配置，可以用文本文档打开：</p>
<p><img src="https://pic.imgdb.cn/item/6115da755132923bf852a7f8.jpg" alt="图集配置"></p>
<p>将这两个文件一起拷贝粘贴到 Unity 工程里：</p>
<p><img src="https://pic.imgdb.cn/item/6115d8d85132923bf84fe4cf.jpg" alt="粘贴到工程里"></p>
<p>可以看到，行走图已经自动被分割好了！这样就不用手动切图啦！</p>
<h2 id="插件规范"><a href="#插件规范" class="headerlink" title="插件规范"></a>插件规范</h2><p>在导入插件后发现目录出现了一个文件夹：</p>
<p><img src="https://pic.imgdb.cn/item/6115d94a5132923bf850a573.jpg" alt="插件的文件夹"></p>
<p>直接放在根目录明显不美观而且也不规范。<br>创建一个 <code>Plugins</code> 文件夹用来存放插件：</p>
<p><img src="https://pic.imgdb.cn/item/6115d98c5132923bf851194b.jpg" alt="Plugins"></p>
<p>虽然插件放在哪 Unity 都会自动加载，但是为了统一管理，添加一个用来保存插件的文件夹是最好的。</p>
<h2 id="动画制作"><a href="#动画制作" class="headerlink" title="动画制作"></a>动画制作</h2><p>行走图切割完成之后，如果使用 Unity 自带的动画程序就比较麻烦了。<br>每一个动画都要添加状态机，并且还要给每一个角色节点添加动画组件，总体的工程量非常大。</p>
<p>所以这里要在框架里面实现一个动画系统。</p>
<h3 id="加载行走图"><a href="#加载行走图" class="headerlink" title="加载行走图"></a>加载行走图</h3><p>行走图切割完后放在 Resources 文件夹备用。<br>新建框架类 <code>Spriter</code>，添加一个读取切割好的图片的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace FR</span><br><span class="line">&#123;</span><br><span class="line">    public class Spriter : MonoBehaviour</span><br><span class="line">    &#123;</span><br><span class="line">        public static Sprite[] LoadSprites(string path)</span><br><span class="line">        &#123;</span><br><span class="line">            Sprite[] sprites &#x3D; Resources.LoadAll&lt;Sprite&gt;(path);</span><br><span class="line"></span><br><span class="line">            return sprites;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里我重新修改了所有框架类的命名空间，全部只套一层 FR，不再区分更细的目录。</p>
</blockquote>
<h3 id="行走图动画"><a href="#行走图动画" class="headerlink" title="行走图动画"></a>行走图动画</h3><p>行走图的动画可以用 Unity 的动画系统实现，也可以自己手动实现，每个游戏都不一样，因此不应该放在框架中处理，而是要放到游戏本身的逻辑当中。</p>
<p>添加一个地图角色父类 <code>AbstractCharacter</code>，该方法继承框架的 <code>Character</code>，并且提供了载入行走图以及显示动画的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using FR;</span><br><span class="line"></span><br><span class="line">namespace Refactor</span><br><span class="line">&#123;</span><br><span class="line">    public abstract class AbstractCharacter : Character</span><br><span class="line">    &#123;</span><br><span class="line">        protected bool isWalking;</span><br><span class="line">        protected Dictionary&lt;string, Sprite[]&gt; animateSprites;</span><br><span class="line"></span><br><span class="line">        protected int animateIndex;</span><br><span class="line">        protected float walkingInterval &#x3D; 0.15f;</span><br><span class="line">        protected float spriteAnimateTime;</span><br><span class="line"></span><br><span class="line">        protected void LoadAnimateSprites(string characterName)</span><br><span class="line">        &#123;</span><br><span class="line">            animateSprites &#x3D; new Dictionary&lt;string, Sprite[]&gt;();</span><br><span class="line"></span><br><span class="line">            string[] fields &#x3D; new string[] &#123; &quot;walk&quot;, &quot;idle&quot; &#125;;</span><br><span class="line">            string basePath &#x3D; &quot;Sprites&#x2F;Character&#x2F;&quot; + characterName + &quot;&#x2F;&quot;;</span><br><span class="line"></span><br><span class="line">            foreach (var field in fields)</span><br><span class="line">            &#123;</span><br><span class="line">                var items &#x3D; Spriter.LoadSprites(basePath + field);</span><br><span class="line"></span><br><span class="line">                if (items.Length !&#x3D; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    animateSprites.Add(field, items);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected virtual void AnimateMonitor()</span><br><span class="line">        &#123;</span><br><span class="line">            WalkingAnimate();</span><br><span class="line">            IdleAnimate();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void SetCurrentAnimateSprite(string key)</span><br><span class="line">        &#123;</span><br><span class="line">            if (animateSprites.ContainsKey(key) &#x3D;&#x3D; false)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.Log(&quot;没有找到对应的动画文件：&quot; + key);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            spriteAnimateTime &#x3D; Time.time + walkingInterval;</span><br><span class="line"></span><br><span class="line">            animateIndex++;</span><br><span class="line"></span><br><span class="line">            if (animateIndex &gt;&#x3D; animateSprites[key].Length)</span><br><span class="line">            &#123;</span><br><span class="line">                animateIndex &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var sprite &#x3D; animateSprites[key][animateIndex];</span><br><span class="line">            SetSprite(sprite);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected virtual void IdleAnimate()</span><br><span class="line">        &#123;</span><br><span class="line">            if (isWalking &#x3D;&#x3D; false &amp;&amp; Time.time &gt; spriteAnimateTime)</span><br><span class="line">            &#123;</span><br><span class="line">                SetCurrentAnimateSprite(&quot;idle&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected virtual void WalkingAnimate()</span><br><span class="line">        &#123;</span><br><span class="line">            if (isWalking &amp;&amp; Time.time &gt; spriteAnimateTime)</span><br><span class="line">            &#123;</span><br><span class="line">                SetCurrentAnimateSprite(&quot;walk&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected virtual void InputMonitor() &#123; &#125;</span><br><span class="line">        protected virtual void InputHandle() &#123; &#125;</span><br><span class="line"></span><br><span class="line">        protected void Update()</span><br><span class="line">        &#123;</span><br><span class="line">            InputMonitor();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected void FixedUpdate()</span><br><span class="line">        &#123;</span><br><span class="line">            WalkingAnimate();</span><br><span class="line">            IdleAnimate();</span><br><span class="line">            InputHandle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的脚本会自动加载角色的图集文件：<code>walk</code>（行走） 和 <code>idle</code>（待机）。<br>需要在 Resources 添加好对应的图片，以后所有的角色都遵循这个标准，即包含一个行走图和待机图。</p>
<p><img src="https://pic.imgdb.cn/item/6115db475132923bf8543d20.jpg" alt="图片放置"></p>
<p><code>InputMonitor</code>（输入监听器） 和 <code>InputHandle</code>（输入处理器）可以在子类重写。</p>
<p>玩家控制的角色类 <code>PlayerCharacter</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using FR;</span><br><span class="line"></span><br><span class="line">namespace Refactor</span><br><span class="line">&#123;</span><br><span class="line">    public class PlayerCharacter : AbstractCharacter</span><br><span class="line">    &#123;</span><br><span class="line">        public float moveSpeed &#x3D; 3.8f;</span><br><span class="line"></span><br><span class="line">        private Rigidbody2D rb;</span><br><span class="line">        private float horizontal;</span><br><span class="line"></span><br><span class="line">        private Vector3 originalLocalScale;</span><br><span class="line"></span><br><span class="line">        protected override void InitCharacterAction()</span><br><span class="line">        &#123;</span><br><span class="line">            LoadAnimateSprites(&quot;ace&quot;);</span><br><span class="line"></span><br><span class="line">            rb &#x3D; GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">            originalLocalScale &#x3D; transform.localScale;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected override void InputMonitor()</span><br><span class="line">        &#123;</span><br><span class="line">            horizontal &#x3D; Input.GetAxisRaw(&quot;Horizontal&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected override void InputHandle()</span><br><span class="line">        &#123;</span><br><span class="line">            MoveHandle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected void MoveHandle()</span><br><span class="line">        &#123;</span><br><span class="line">            rb.velocity &#x3D; new Vector2(horizontal * moveSpeed, 0);</span><br><span class="line"></span><br><span class="line">            if (horizontal !&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                isWalking &#x3D; true;</span><br><span class="line">                float scaleX &#x3D; horizontal &gt; 0 ? -1 * originalLocalScale.x : originalLocalScale.x;</span><br><span class="line">                SetLocalScale(scaleX);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if (isWalking &#x3D;&#x3D; true)</span><br><span class="line">                &#123;</span><br><span class="line">                    animateIndex &#x3D; 0;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                isWalking &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NPC 的角色类 <code>NonePlayerCharacter</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">using FR;</span><br><span class="line"></span><br><span class="line">namespace Refactor</span><br><span class="line">&#123;</span><br><span class="line">    public class NonePlayerCharacter : AbstractCharacter</span><br><span class="line">    &#123;</span><br><span class="line">        protected override void InitCharacterAction()</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>目前还未开始实现 NPC 角色，因此留空备用。</p>
<p><img src="https://pic.imgdb.cn/item/6115d0f85132923bf8431441.gif" alt="行走测试"></p>
<h2 id="角色类的新设计"><a href="#角色类的新设计" class="headerlink" title="角色类的新设计"></a>角色类的新设计</h2><p>与前一篇相比，角色基类的改动比较大。<br>最大的不同是节点的创建，在前一篇中是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义一个字典用于保存场景中的NPC节点</span><br><span class="line">private Dictionary&lt;string, GameObject&gt; npcs &#x3D; new Dictionary&lt;string, GameObject&gt;();</span><br><span class="line"></span><br><span class="line">public GameObject CreateNPC(FR_Data.CharacterData data)</span><br><span class="line">&#123;</span><br><span class="line">    GameObject obj &#x3D; new GameObject();</span><br><span class="line"></span><br><span class="line">    obj.name &#x3D; data.name;</span><br><span class="line">    SpriteRenderer spriteRenderer &#x3D; obj.AddComponent&lt;SpriteRenderer&gt;();</span><br><span class="line">    spriteRenderer.sprite &#x3D; Resources.Load&lt;Sprite&gt;(data.walkingGraphPath);</span><br><span class="line">    spriteRenderer.sortingOrder &#x3D; data.sorting;</span><br><span class="line"></span><br><span class="line">    npcs.Add(data.name, obj);</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述脚本通过代码动态创建一个 NPC 节点。</p>
<p>但是我突然想到，NPC 节点有体型的差异，比如场景中如果出现一只 BOSS，那么它的体型可能比玩家大好几倍，这样的话碰撞器的范围就难以用脚本的方法控制了。因为素材是存在多余的透明区域的，而脚本只能读取到图片的大小，要计算出不透明的宽高就比较麻烦了；所以我决定还是创建一个角色预制体，角色的预制体不需要添加逻辑脚本，而只是一个没有“芯片”的机器人，每一个 NPC 的逻辑都不同，只要给它们植入“控制芯片”就可以了。</p>
<p>角色预制体相当于是角色的模型，只差给它们“注入灵魂”。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">火烧兔子</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://huotuyouxi.com/2021/08/13/monster-game-13/">http://huotuyouxi.com/2021/08/13/monster-game-13/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://huotuyouxi.com">火兔游戏工作室</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/">开发技术</a><a class="post-meta__tags" href="/tags/unity/">unity</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/08/17/monster-game-14/"><i class="fa fa-chevron-left">  </i><span>《名为怪物的游戏》框架开发篇（优雅的实现菜单系统）</span></a></div><div class="next-post pull-right"><a href="/2021/08/10/monster-game-12/"><span>《名为怪物的游戏》框架开发篇（场景系统）</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2021/05/02/61DLs9VHetxbq2n.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2023 By 火烧兔子</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>